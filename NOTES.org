# -*- org-tags-column: -98 -*-

* Use flatbuffers for RPC serialization							      :FR:
- https://github.com/google/flatbuffers

* Message router									      :FR:
- Send messages to ports, which might live in another process.
- Ports have a unique ID within its process.
- Port address is (process ID, port ID).
- Messages to other processes are sent over IPC channel.
- Process's IPC server routes message to local port.
- IPC server address can be queries from ProcessManager.
  - Create stubs on demand?
- RPC are implemented as request/reply pair with a unique RPC id.
  - RPC client tracks set of outstanding RPC, by RPC id.
* stats module										      :FR:
- graph rendering slows down UI
- label stats with process name
- operations
  - aggregate functions
    - sum, min, max
  - rate over interval
  - mean over interval
- StatMonitor:
  - history
  - presets
  - time axis
    - render
    - select range
  - key
    - different colors per graph
    - show non-common labels
     - latest values
  - vertical range
    - round min/max
    - render grid
  - correct rendering along x axis
    - map timestamps to x position
    - interpolation
* LV2 support										      :FR:
** Native UI support
- ref implementation:
  - http://dev.drobilla.net/browser/suil
  - http://dev.drobilla.net/browser/jalv
- spawn UI specific process for each plugin
- pass port value changes from audioproc process to UI
  - for every block cycle or rate limited to Xfps?
** features
- check for required features when listing plugins
- plugins with unsupported features:
  - just skip with LOG message?
  - include in NodeDB, but mark as non-functional, with reason text?
- provide features
  - which ones are most common?
  - http://lv2plug.in/ns/ext/urid/urid.html
    - http://lv2plug.in/ns/ext/urid#map
  - http://lv2plug.in/ns/ext/worker/worker.html
    - http://lv2plug.in/ns/ext/worker#schedule
  - http://lv2plug.in/ns/ext/options/options.html
    - http://lv2plug.in/ns/ext/options#options
  - http://lv2plug.in/ns/ext/buf-size/buf-size.html
    - http://lv2plug.in/ns/ext/buf-size#fixedBlockLength
    - http://lv2plug.in/ns/ext/buf-size#boundedBlockLength
** event/atom ports
* ipc.Server: shutdown waits for outstanding commands to finish				     :BUG:
- could crash in ServerProtocol.command_complete, if Server instance has already been cleaned up
- does it need to lameduck?

* SheetEditor: show/hide tracks does work anymore 					     :BUG:
* ScoreEditorTrackItem: Improve rendering						      :FR:
** ghost notes should be closer to real insert position
** squeeze notes into measure, if duration is exceeded
** render exceeding notes differently
** proper chord rendering
** note beams
** use http://www.smufl.org/?
- fonts & data files: https://github.com/musescore/MuseScore/tree/master/fonts
* Exception when reordering tracks 							   :CRASH:
Traceback (most recent call last):
  File "/storage/users/pink/projects/noisicaä/noisicaa/ui/tracks_dock.py", line 499, in onCurrentChanged
    not track.is_master_group and not track.is_first)
  File "/storage/users/pink/projects/noisicaä/noisicaa/core/model_base.py", line 410, in is_first
    raise NotListMemberError(self.id)
noisicaa.core.model_base.NotListMemberError: 32e1b62e20524d16a584c65311960356

* Exception on shutdown									   :CRASH:
Traceback (most recent call last):
  File "/storage/users/pink/projects/noisicaä/noisicaa/core/process_manager.py", line 236, in start_process
    rc = impl.main(ready_callback)
  File "/storage/users/pink/projects/noisicaä/noisicaa/core/process_manager.py", line 386, in main
    self.main_async(ready_callback, *args, **kwargs))
  File "/usr/lib/python3.5/asyncio/base_events.py", line 387, in run_until_complete
    return future.result()
  File "/usr/lib/python3.5/asyncio/futures.py", line 274, in result
    raise self._exception
  File "/usr/lib/python3.5/asyncio/tasks.py", line 239, in _step
    result = coro.send(None)
  File "/storage/users/pink/projects/noisicaä/noisicaa/core/process_manager.py", line 409, in main_async
    await self.cleanup()
  File "/storage/users/pink/projects/noisicaä/noisicaa/music/project_process.py", line 225, in cleanup
    await self.node_db.cleanup()
  File "/storage/users/pink/projects/noisicaä/noisicaa/node_db/client.py", line 34, in cleanup
    await self.disconnect()
  File "/storage/users/pink/projects/noisicaä/noisicaa/node_db/client.py", line 46, in disconnect
    await self._stub.call('END_SESSION', self._session_id)
  File "/storage/users/pink/projects/noisicaä/noisicaa/core/ipc.py", line 357, in call
    raise ConnectionClosed
noisicaa.core.ipc.ConnectionClosed

* when changing scale_x, keep view centered on current position				      :FR:
* control playback position								:ANNOYING:
- rewind to start
- move manually
- loop range

* clarify time handling									 :CLEANUP:
- musical time
  - base unit full note (4 beats)
- wall time
  - base unit 1sec
  - tracked as fraction, e.g. (sample_pos/sample_rate)
- UI renders musical time, i.e. 100 horizontal pixels always map to a fixed musical time interval
- wall time = musical time / (bpm / 4 / 60)
- get rid of ticks
- work out how changing bpm works
- single TimeMapper per sheet

* use libsndfile									      :FR:
- instead of custom WAVE parsing

* TODO Audio tracks									      :FR:
- rendering
- don't use a normal command, make it a special call
- drag'n'drop sections onto audio tracks
- a section is a clip or range of a clip
- per section envelope
  - short (few msec) ramp up/down to avoid clicks
- manage list of samples owned by sheet
- garbage collect unused samples
- handle samples with different sample rate
  - resample at playback
  - or resample full sample at playback and cache result
  - or resample full sample when importing it
- mono/stereo tracks
  - select when creating track
  - mono samples can be placed on left, right or both channels
  - stereo samples are downsampled on mono tracks

* Pan node										      :FR:
- left/right
* Store IDs of pipeline graph nodes in track						 :CLEANUP:
- refs from PipelineGraphNode should use IDs, too

* Play head is completely off after measures are added					:ANNOYING:
* More flexible instrument handling							      :FR:
Use display_name in track_property_dock
- query instrument_db for description
- fallback to URI, if description not found


Async scanning
- UI installs listener to get updates when InstrumentDescription of an URI changed
  - InstrumentDBClient also calls 'mutation:$(uri)' callback
  - TrackItem and TrackPropertiesDock

Full vs. incremental scans
- report scan progress to clients

Deep scanning
- instrument type, mtime
- sample_scanner:
  - any metadata (copyright, ..) in common headers? iXML?
- soundfont_scanner
  - fields from soundfont.py
  - audio format data (#channels, sample rate, sample format)?

Handle file moves
- store file checksum
- when same checksum with different path detected, then...?
  - custom attributes are keyed by checksum?

Organize library
- add custom attributes to instruments
  - star items
  - tags
  - comments

Add individual files
- dialog or filesystem browser in the UI?
- integration with external sources (freesound.org, etc.)?

Library UI
- keep list sorted
  - when inserting new items, sort by display_name
  - how to do that O(log n)?
- icon for instrument type
- filter lists by
  - tags
  - only starred
  - mono/stereo
  - sample rate (range)
  - sample format
- edit multiple entries
  - add/remove tag/star
- view as tree by
  - path
  - tag
- query DB if selected file is up-to-date
  - show "File has changed, rescan" button
  - install listener on URI to update info fields when changed
- keep list in sync added/removed files
- menu
  - Incremental scan
  - Full scan
- status bar with progress while scanning
  - when finished: Library scan finished XX ago: %d added, %d removed, %d updated
  - status is tracked by app
    - status:
      - 'init_scan', #files_found
      - 'scanning', #files_done, #files_total
      - 'done', done_timestamp, #inst_added, #inst_remove, #inst_updated

* Session state										      :FR:
- store binary log for efficiency
- replay log on open
- checkpoints

Stores
- have std handlers to connect a widget to UI state
  - when connecting, should set values from session
  - sets up listeners to sync widget state to session
  - QTabWidget
- pipeline node enabled state
- track/node mute/solo/visible states
- current track

* Gracefully handle pipeline crashes							      :FR:
Blacklist crashing nodes
- user can manually reactivate node
- directly mark node as broken, when it throws an exception during setup() or run()
- when building initial state, mark nodes as broken from session state.
- also send error message to UI
  -> or pull with player.get_node_state(id)?

* Graceful AudioStream shutdown								      :FR:
send close message to backend

* InstrumentLibrary: remember the selected MIDI source					      :FR:
* Fix removing measures									     :BUG:
- remove measure on SheetPropertyTrack causes exception
- no way to remove trailing measures from sheet

* Unify instrument handling in ScoreTrack and BeatTrack					 :CLEANUP:
* Move BackendManager to noisicaa.core							 :CLEANUP:
* Review licenses of all used modules							      :FR:
All compatible with GPL?
* SampleInstrument: tuning								      :FR:
Set the base tuning of the instrument.
- also look at sample rate (ftsr function)

* reanimate PipelineGraphMonitor							     :BUG:
- doesn't know how to handle changing address of audioproc process

* Node presets										      :FR:
- track current directory for import/export file dialogs
  - which default directory?
- which file extension?
- serialize port list (if editable)
- serialize param descriptions (if editable)
- add to nodedb
  - nodedb scans preset directory
  - store presets in $HOME/.noisicaä/presets
- node remembers preset it was created from (or saved to)
- UI
  - save as
  - save (if linked to preset)
  - load from preset
    - select from all presets for this node URI
  - import/export
    - load/save to arbitrary paths
  - edit metadata
- metadata
  - open "edit metadata" dialog on "save as" or "export"
  - author
  - copyright
  - license
  - comment
* Control tracks									      :FR:
Any controllable value can be turned into a control track.
Icon next to controllable values, drag'n'drop onto editor.

- should control tracks be measured?
  - if not, inserting a new measure across all tracks becomes non-obvious
  - if not, layouting needs to be reimplemented
    - each track has its own layout
    - but measures should still align
  - control tracks should still be rendered as a sequence of measures,
    aligned to the other tracks
  - if yes, moving control points across measure boundaries becomes
    non-trivial
- what happens when the song becomes shorter than a control track?
  - discard all control points past the end
    - clip last segment correctly?
  - or keep control points, but just don't show them
  - or keep track length
- splines?
- free hand
- properties
  - min/max
  - linear/log
  - unit (Hz, dB, %, ..)
- display current value under cursor position
- edit track properties
- implicit first and last segment
  - extend current value from start or end
- ControlEntitySource: compute value at a-rate

* ToolDock: track specific tool set							      :FR:
- active track:
  only the active track gets edit events. clicking on another track makes
  that track active and changes the set of tools and the active tool.
- remember active tool per track type
- could also activate track by enter events
  - but if mouse then moves to tracks dock, it might cross other tracks causing confusion
* Default track effects									      :FR:
When creating new track, insert standard set of effects in pipeline.
Default effects to bypass.
Reverb, Delay, Pan, Equalizer.
* Pipeline: don't execute unused nodes							      :FR:
Skip node's run(), if all its outputs are bypassed.
Skip node, when there are no unmuted upstream nodes. Pass this on, to disable complete subtrees.
* Mixer strip										      :FR:
Create mixer panel for each track.
Add controls or monitors with drag'n'drop.

* Reparent mixer nodes when moving tracks between groups 				     :BUG:
When reparenting a track, also reparent its mixer node.

* turn any node parameter into a control input port					      :FR:
- ports can be added and removed on the fly
- parameter description has sufficient data to describe port
- parameter is always a-rate in csound

* Exception when closing a project 							     :BUG:
- 'dict_values' object is not an iterator
- no traceback?

* Most instruments should produce mono data						 :CLEANUP:
* Abstract base class for ui mixins							 :CLEANUP:
- to make pylint happy

* Revamp object model									 :CLEANUP:
- root manages heap of objects
- when creating object, add it to heap
  - __init__ needs to know root, so it can create children
  - or separate setup() method?
- all object references (child, lists, etc.) only store IDs in state, do
  lazy dereferencing on __get__
* Use "def foo(*, ...)" to enforce keyword-only functions				 :CLEANUP:
* BeatTrack: move beats to arbitrary positions						      :FR:
* Sometimes hangs during shutdown							     :BUG:
Last sign of life:
  INFO    :18195:7f91c16bc700:ui.editor_app: Shutting down.

* ScoreMeasure: only show clef, time- and key-signature when changed			      :FR:
- if is_first or if different from prev_sibling
- how is a keysignature change rendered that removes accidentals? e.g. to c-major

* More precise playback timepos reporting						      :FR:
Currently the UI is behind a bit because of buffering in the pyaudio backend.
- Backend in main audioproc pipeline has a callback that reports the timepos of the block actually
  sent to the driver.
- IPCNode listens on that and forwards to the player's IPCBackend.
- IPCBackend applies timepos_offset and reports back to Player.
- Player sends timepos to UI.
* Built-in way to split/join channels							      :FR:
- how often do you have to go from mono->stereo or vice versa?
- going through splitter/joiner nodes is too cumbersome
- implicit up/down mixing in Port.collect_inputs?
* Ports that that any number of channels						      :FR:
- specify that an output port has the same number of channels as an input port.
- number of channels changes at runtime
- or do nodes always just take frames and mismatching channel number is a runtime error?

* Audio pipeline sends data back to UI							      :FR:
- For VU Meters, spectograms, etc.
- Player buffers data frames.
- When player receives the matching timepos from the main pipeline, send buffered data
  to player client.

* store sockets and pipes in $HOME/.noisicaa/run and cleanup after yourself.		      :FR:
- also clean up old files when starting up
- host specifc subdirs? host-pid?
- how to figure out if a dir is obsolete?
  - some lock file, which is held by the main process. if you can acquire it, remove the dir.
  - some file that main process touches every Xmin. if older than Ymin, remove the dir.
  - a socket that main process listens on. if you can't connect to it, remove the dir.

* Custom csound filter node								      :FR:
- make port list editable
- report csound errors back to UI
  - capture logs while setting orchestra/score
  - needs some mechanism to report events from audioproc pipeline back to UI
- big red button
  - tear down current csnd instance
  - needs some mechanism to send action events to audioproc node
- two engines - new/old code - in parallel, slide from old to new
  - init new code
  - start processing new code , output at 0
  - slide old=100%, new=0% -> old=0%, new=100%
  - stop processing old code
  - clean up old code
  - how does that work with arbitrary output nodes? and events?
- edit widget with syntax highlighting

* cleanup audioproc.Node.__init__ signature						 :CLEANUP:
store node uri

* merge consecutive commands								      :FR:
- keep a single item in-memory buffer before writing commands to disk
- when adding commands to log
  - call prev_cmd.try_merge_with(latest_cmd)
    - command class must be marked as mergable
    - if same class, append mutation log of latest_cmd to prev_cmd?
    - or just handle simple attribute changes, overwriting the target value
  - if returns False, push latest_cmd to log (flushing prev_cmd to disk)

* per measure time signature								      :FR:
Tracks can have different time signatures, measures do not have to align
vertically.
* Background eventset 									      :FR:
Internal data structure that tracks noteon/noteoff events for a track.
Efficient lookup of:
- events in a given time interval.
- list of notes that are on in a given time interval.
Used by event based tracks (score, beat, ...).
Track syncs all changes to eventset.
Use eventset to generate player events.

* ScoreTrack: tweak noteon position, duration						      :FR:
- control properties of track
- offset for noteon events
- multiplier of note duration
- probably best to implement after background eventset

* Note fine tuning									      :FR:
Tweak time of noteon/noteoff for each note.
Only active at high zoom levels.

* replace SheetPropertyTrack by a controllable parameter				      :FR:
- bpm is a parameter of Sheet
- optionally make it a ControlTrack to change it over time.
* SIGSEGV when editing PipelineGraphView						   :CRASH:
Possibly caused by the use of QGraphicsEffect for dropshadows?

* GIL free audio pipeline								      :FR:
* Render audio to file									      :FR:
* NodeDB: start_scan									      :FR:
How to report scan progress back?
First a quick scan to find candidate files?
* NodeDB: set search paths								      :FR:
Manage from settings dialog.
Search path per scanner (csound, ladspa, lv2, ...).
* NodeDB: cache DB									      :FR:
Storage location: $HOME/.cache/noisicaä
Track time of scan
Load cache on startup
Rescan if time of last scan > X
* Run LADSPA plugins at higher rate							      :FR:
So changing control parameters are updated at a fixed rate instead of the backend's frame size.
Do it like csound, call run() with e.g. num_samples=32 until output buffer if filled.

* PipelineGraphView: edit node name							      :FR:
* Track volume/mute properties: change connect trackmixer node instead.			     :BUG:
* Color code tracks and measures.							      :FR:
Tracks: To group e.g. all percussion visually.
Measures: To group thematically related sections.
Popup menu provides palette of color, separate list of already used colors
(to make it easier to answer the question, which shade of green I used
before).

* Linked measures									      :FR:
Dereference: clone the pointed to measure and replace link with that copy.
If a group of linked measures is selected, only make one copy and link the
rest. E.g. A B A' B' [A' B' A' B'] -> A B A' B' C D C' D', where C=copy(A),
D=copy(B).
Explicit dereference all to create standalone clone for every selected
measure.

* PipelineGraphView: drop onto existing node to replace it.				      :FR:
Retain properties of the same name from replaced node.
Deny drop, if node is not compatible with existing node.
* PipelineGraphView: drop new node on connection.					      :FR:
Insert node between the connected nodes.
Deny drop, if node is not compatible with connection type.
Reorganize graph to make space for the new node.

* PipelineGraphView: node info in nodes list.						      :FR:
List of ports and their types.
Node description, etc.
* PipelineGraphView: disallow connections that create a cyclic graphs.			     :BUG:
Compute list of valid dest nodes and highlight those.
* PipelineGraphView: scrollwheel zoom.							      :FR:
* PipelineGraphView: drag to move.							      :FR:
* PipelineGraphView: no random jumping around when inserting new nodes.			      :FR:
* PipelineGraphView: multiple selections.						      :FR:
** ctrl-click to add/remove nodes from selection set.
** Way to select all upstream nodes of a node.
** Move nodes together.
** Remove all
* PipelineGraphView: visualize mute, volume, bypass state in UI				      :FR:
* PipelineGraphView: select port or connection filters node list to compatible nodes	      :FR:
* ScoreMeasure: improve rendering for different zoom levels				      :FR:
At low zoom levels, don't render full notes, just dots.

* More instrument types									      :FR:
- SFZ
- arbitrary plugin
* Lens											    :IDEA:
At low zoom levels, click on an area to popup an overlay window showing that area at a higher
zoom level for editing.

* Canvas tracks										    :IDEA:
Free form painting on the track.
Turn into array of a-rate values to feed into instrument.
E.g. each row is an oscillator, row index is pitch, value is frequency.
Do crazy stuff in csound.

* Track freezing									    :IDEA:
- render audio at track mixer, write to file
- replace track with playback of that frozen audio data
- gain/mute on track mixer still works
- also freeze output of all upstream nodes, that are connected to nodes outside of track
- all upstream nodes of track mixer in PipelineGraphView are disabled
- rerender track
- unfreeze track

* cut, copy, paste									      :FR:
- Use QClipboard
- select multiple items
  - ranges or sparse sets
- measures across different tracks
- different selection types
  - mutually exclusive
    - when a different type is selected, clear selection
  - measures
  - tracks
  - notes

* copy/link via drag'n'drop								      :FR:
* notes on the grid									      :FR:
Alternate editing mode for ScoreMeasures.
Insert notes at absolute time positions, recompute duration of preceding note.
Switch with insert/overwrite key?
How to deal with very short notes? I.e. grid too small.
- set grid size based on visual scale, zoom in to get shorter intervals.
What about triplets etc. which are off the grid?
* player needs to get lock on state							     :BUG:
possible exception when changing project while playing
* Tool not visible on initial load							     :BUG:
* changing backend in settings crashes pipeline loop					     :BUG:
* Undo/redo doesn't replay pipeline mutations						     :BUG:
- trigger pipeline mutations from listeners on model
- don't trigger mutations while replaying log during load
- store pipeline mutations as operations in command?

* use recordfile for command log							 :CLEANUP:
   * need file offset
   * read record from offset
* cleanup and write docstring for storage.py						 :CLEANUP:
* delete unused objects on client side, when						 :CLEANUP:
   * obj prop set to None
   * item deleted from objlist
   * objlist cleared
* make consistent use of __private attributes						 :CLEANUP:
* consistent naming of close()/cleanup() methods					 :CLEANUP:
* replace isinstance(..., model.TrackGroup) with a is_group property			 :CLEANUP:
* non-existing file on cmdline creates project						      :FR:
   * remove + hack

* main process keeps track of project processes						      :FR:
   * opening existing project reconnects to that process

* per process cpu monitor								      :FR:
   * collect cpu time with 1ms precision
   * separate thread
   * send bulk data every O(100) ms to UI
   * plot along pipeline perf chart
* PipelinePerfMonitor: aggregate data over time						      :FR:
- avg duration and std deviation per span.
- how to visualize averaged gantt chart?
* PipelinePerfMonitor: per span graphs
- duration
- start time relative to parent span
- start time relative to frame start

* process stats										      :FR:
   * STATS call to manager
   * name, pid, cpu, memory
   * graphs

* stats for backend buffer length							      :FR:

* project_fuzztest.py									 :TESTING:
   * launch ProjectProcess using same eventloop
   * use inmemory filesystem
   * random actions
      * close and reopen
      * create checkpoint
      * undo/redo
      * player interaction
      * execute all existing commands
      * coverage report
* integrate pylint into test suite							 :TESTING:
   * add test case with test for each covered module
   * run pylint and fail test if any found messages
* XML schema for node descriptions							 :TESTING:
   * validate all nodes from library against schema
* parse all csound scripts for syntax errors						 :TESTING:
UI Improvements

* better handling of remote exceptions							 :CLEANUP:
   * traceback
   * every exception crashes
      * Server errors terminate server process
      * traceback sent to process manager, propagate to process owner
      * exceptions in threads terminate process
      * handle simultaneous exceptions in multiple threads

* master volume										      :FR:
if backend supports volume, use that. e.g. set alsa mixer volume.
otherwise set volume on outgoing samples.

* NodeType -> NodeDescripion								 :CLEANUP:
* Description classes for ports and node properties					 :CLEANUP:
* move generic Qt classes to noisicaa.qt						 :CLEANUP:
* LoadHistoryWidget									 :CLEANUP:
* fix left over TODOs									 :CLEANUP:
* remove or fix commented code								 :CLEANUP:
* ServerError and ClientError exception base classes.					 :CLEANUP:
- ClientError is returned to client
- ServerError causes server to crash
* factor out common Client, Process, Session code					 :CLEANUP:
* separate client, server and common code in music					 :CLEANUP:
* proper classes for mutations emitted from state.py					 :CLEANUP:
* move tests from state_test.py to model_base_test.py					 :CLEANUP:
* find a proper test sample for audio settings dialog					 :CLEANUP:
* move initial project mutations to BaseProject						 :CLEANUP:
* node_db imports all nodes and populates itself					 :CLEANUP:
* use registry instance instead of class attributes to track classes			 :CLEANUP:
that allows distinct class hierarchies and is cleaner for testing
music.commands.Command.command_classes
* AudioProcClient should use callbacks for mutation and status distribution		 :CLEANUP:
instead over overriding handle_pipeline_*, client code should register a callback
* base class for audioproc nodes created from a NodeDescription				 :CLEANUP:

* add a concept of "action receivers"							 :CLEANUP:
- EditorWindow has a single object currently being the "action receivers"
  - use Qt focus?
- global actions, e.g. cut, copy, paste, are sent to that object
- if receivers doesn't handle it, pass it on to parent
  - use custom Qt events?

* Guitar track										    :IDEA:
- physical simulation of guitar strings
- edit finger positions
- edit strokes

* Move the various cython bindings to noisicaa.bindings					 :CLEANUP:

* == unsorted nodes from gdoc =================================================

* use URIs to open files
   * always abs path
   * demo://params

* use stats calls to other processes
   * for pipeline utilization
* TracksDock: drag'n'drop to organize tracks
Assorted TODOs
* pass done callback to start_process
* first flesh out AudioProc process
   * prevent cycles 
   * handle node parameters
      * default values for parameters
      * update parameters
         * open dialog
         * mark parameters as mutable
         * client and process methods
   * pass user-data along with commands, pass back to client along with mutations. use for e.g. initial position of nodes when dragging.
   * monitors
      * attach to any input or output port
      * for audioports
         * waveform, vumeter, spectrum
   * system midi event source 
      * one port per channel?
   * support note volume
      * just multiply each audiooutput buffer after run()?
   * race condition in audioproc_client_test.ProxyTest.test_remove_node?
      * occasional "ERROR:noisicaa.audioproc.audioproc_process:PUBLISH_STATUS failed with exception: 'NoneType' object has no attribute 'write'"
* UI state vs. project state
   * UI state:
      * current sheet, track, etc.
      * selections
      * position in view, zoom level, etc.
   * there could be multiple UIs for a project
   * same UI state spans projects
      * window/dock positions, sizes
   * project mutations might affect UI state
      * selected track is removed, etc.
      * undo should recreate related UI state changes
         * undo delete current track -> re-added track becomes current
* cli:
   * subcommands 
      * edit path
      * create path
      * play path 
      * encode path
   * global vs. per command flags
   * move command handlers to submodules
* CLEANUP: Use state pattern to handle tools
* UI: show on cursor when an operation is not allowed
* UI: press ‘h’ to highlight all locations where the current tool is applicable
* ties/slurs:
   * either: note groups or markers
   * markers:
      * begin, continue, end
      * adding begin/continue marker, adds end marker to next note
      * continue/end marker implies prev note has begin/continue marker
      * note can have multiple markers
         * A(b) B(c,b) C(e,c) D(e):
  
         * should markers have some group_id to identify which slur they belong to?
         * would it be sufficient to just list the group_ids for each slur that a note belongs to? if it’s the beginning/middle/end could be deduced. but that knowledge is handy for rendering and playback
   * groups:
   * track wide list of groups
   * add notes to groups
   * notes have reference to groups
   * find other notes in group requires cyclic references
   * edit flows:
   * click on note that is currently ‘end’
   * becomes ‘continue’, next note becomes ‘end’
   * click on note before ‘begin’
   * becomes ‘begin’, next note becomes ‘continue’
   * click on note that is currently ‘begin’, ‘continue’
   * no-op
* midi
   * MidiHub
   * list keyboards, controls, buttons - not ports
   * route messages to driver
   * drivers
   * generic_midi_keyboard
   * driver configs
   * velocity function (min, max, gamma)
   * octave transpose
   * libalsa
   * more generic DeviceInfo, instead of Client-/PortInfo
* don't leave trash behind, if Project.create fails
* log_dump util
* https://travis-ci.org/ integration
* measure layout
   * align notes across tracks
* proper chord rendering
* ghost note at insert point
   * correct insert position for last note in measure
   * use tinted note instead of transparent
   * http://www.qtcentre.org/threads/53946-Is-it-possible-to-change-color-of-a-QGraphicsSvgItem
* selections
   * select measures & tracks
   * clear
   * transpose
   * cut, copy, paste
* InstrumentLibrary
   * update UIState as changes happen
   * use commands for changing library state
   * persist state
   * main instrument library - where should the state go?
   * track selection dialog: store ui_state under track
* signal buffer underruns
* when muting a track during playback, remove highlighted note
* more efficient layouting
   * measureitem.recomputelayout tells sheet about changes
   * sheet decides which measures need relayouting
   * just update measure positions
* UI: only show clef, time-, key signature when different from previous measure
* UI: cursor graphics item position should be updated when the view is scrolled.
* UI: better scrolling when following the playback position
   * either smooth scrolling, or jump one measure at a time.
* UI: time/key signature submenus should indicate current.
* USABILITY: Clicking on/editing a track on the sheet should make it the current track
* USABILITY: Better widget for volume control
* USABILITY: When adding a new track, open instrument selector
* USABILITY: Only show tool cursor when action is valid
   * note/rest: when over a valid insert point
   * accidental: when over a note and accidental is valid for that note
* BUG: switching tool using shortcuts doesn’t update tool dock anymore
* BUG: changing time signature does not update all tracks
* BUG: removing a track does not remove the playback source
* BUG: Collapsed state for docks is not persisted
* BUG: Crash in thread causes problems
   * crash dialog must be created from mainthread
   * send event to main thread
* UI: Tool dock should have a fixed height
* CLEANUP: rename all tests to test_*.py
* CLEANUP: tests for UI classes
* CLEANUP: replace runtests by setup.py test
* FEATURE: rendering
   * file metadata
   * persist dialog values per-sheet
   * more formats: ogg, wav, mp3, ape
   * per-format options: bitrate, vbr/cbr, …
   * open file as *.part, rename at end, delete on failure
   * open dir in filemanager
   * open in external media player
* object browser
* dev dock
   * process memory usage
* lot’s of STDERR on exit
   ** (process:26761): CRITICAL **: fluid_synth_sfont_unref: assertion 'sfont_info != NULL' failed
   fluidsynth: warning: No preset found on channel 245 [bank=0 prog=0]
   is that a problem?
   * probably related to the sfont shuffling between master_synth and playback synths.
* FEATURE: doodle mode
      * record raw midi
      * place markers "this was good"
      * midi controller, button, etc.
      * quantize
* FEATURE: complex instruments
      * need more complex structure that "one instrument per track"
      * instrument definition is track type specific
      * percussion track:
      * list of instruments
      * score track:
      * base instrument
      * (optionally) separate instrument for staccato, pizzicato, ... notes
      * play mode "percussion" (only note on), "note" (note on/off based on duration), ...
* FEATURE: play back tuning
      * all event based tracks
      * global settings
      * per-track settings
      * add to/override global settings
      * shift note on/off times
      * randomize
      * velocity, timeshift based on beat position ("swing -> delay note on on off beat").




* documentation
* doc with html browser
* chord naming
* enable for track
* link chords to documentation, description of chord, etc.
* i18n, german translation
* polyphonic synth for plain wav files
* filters
* parameter timeline
* grand piano staff
* support multiple note sequences per track
* percussion track
* assign different instruments to note symbols
* support multiple instruments per track
* realtime midi input
* recorded audio track
* realtime input
* export to single file archive
* standalone player and exporter
* import/export other formats
* musicxml
* http://www.lilypond.org/doc/v2.18/input/regression/musicxml/collated-files.html (might be useful, if the site is up..)
* abc http://abcnotation.com/
* midi
* vertical rendering
* fit measures into horizontal space, then continue going down
* support more than just stereo
* treat each track as a point in space (possibly with movement and direction)
* output channels are “microphones” placed in space
* render output using a 3d simulation
* saw some library doing that somewhere…
* text input
* show a text input widget below current measure with a text representation of the contents, let user edit and update measure display as it is changed.
* key shortcuts to jump to next/prev measure, up/down a track.
* define syntax, something like ABC
* http://opensoundcontrol.org/introduction-osc


* MIDI controller
      * apc key 25 button mapping: https://github.com/osakared/apc-key-25-bitwig/blob/master/APCKey25.control.js

* Misc notes
      * std icons: http://standards.freedesktop.org/icon-naming-spec/icon-naming-spec-latest.html
      * symbols: http://en.wikipedia.org/wiki/List_of_musical_symbols

* standalone player
* --driver
* -o wav
* statusbar
* show current note value
* select tool
* highlight selected measure
* TAB -> cycle through tools
* ? -> show keyboard shortcuts
* ctrl -> insert pause
* space -> pan view
* helper lines for low/high notes
* volume markers
* edit measures
* context menu over active measure
* remove
* insert left
* insert right
* cut
* copy
* paste
* link
* change clef
* change key
* tracks
* add
* remove
* move up/down
* set instrument
* set volume
* set octave
* time jitter
* load/save project
* remember opened projects
* recent projects menu
* track project is modified status
* display in tab title
* autosave
* bookmarks
* project properties
* composer, copyright, etc.
* “text” tracks
* free text annotations
* beam score to tablet, sync display with playback
