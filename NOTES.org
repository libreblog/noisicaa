# -*- org-tags-column: -98 -*-

* runtests: warn if selector did not match any tests                                     :TESTING:
* what is the proper type for target in noisicaa.ui.tools?                               :CLEANUP:
* refactor noisicaa.ui.editor_window                                                     :CLEANUP:
- just an empty shell that hosts project views
- menubar, toolbar, etc are owned by ProjectView
  - when switching current project view, set the current menubar, toolbar, ...
- dito for dock widgets?
  - dock widgets are hosted in window
  - when switching between projects, dock widgets and their states are stored/restored.
  - ProjectView does not have to be a QMainWindow anymore (which feels hacky anyway).
- can have any number of windows, with some set of projects hosted within each.
  - eacg ProjectView is hosted in exactly one window.

* Use 'object' instead of Any for 'some value'                                   :CLEANUP:TESTING:
- enforces using cast() whenever such a value is used.
- enable mypy to complain about any untyped/Any-types variable.

* use specific versions for venv packages                                                     :FR:
- so venv setup is deterministic
- listdeps --check-updates
  - check for latest versions, list packages with updates

* reanimate pdb                                                                          :TESTING:
* Make target object explicit member of command proto                                    :CLEANUP:
- Remove the Command.target field
- Add an appropriate field the each command proto (or not).

* asyncio.wait() does not raise exception in failed tasks                                    :BUG:
- causes 'task never retrieved' messages, and uncaught exceptions
- always collect results from the done tasks
* Use command CreateX, UpdateX, DeleteX pattern for commands.                            :CLEANUP:
* Add stubs for PyQt5.QtSvg                                                           :FR:TESTING:
* Make control value generations work with undo                                              :BUG:
- generation must also increment, when value change is caused by undo
- track generation outside of model
- but also synchronize generation with model listeners
- some special 'value plus generation' container?
- also use generation for plugin_state

* LV2: implement http://lv2plug.in/ns/ext/presets extension                                   :FR:
- provide list of presets as drop down
- set state and control values

* LV2: implement state reset                                                                  :FR:
- set all ports to default values
- call set_state with empty proto

* LV2: implement ui:portNotification                                                          :FR:
* LV2: implement ui:portSubscribe                                                             :FR:
* Crash when opening a project with an opened plugin ui                                    :CRASH:
          File "/home/pink/noisicaa/build/noisicaa/ui/pipeline_graph_view.py", line 307, in __loadUI
            self.__loading = False
          File "/home/pink/noisicaa/build/noisicaa/ui/project_view.py", line 1332, in createPluginUI
            return await self.project_client.create_plugin_ui(self.__player_id, node_id)
          File "/home/pink/noisicaa/build/noisicaa/music/project_client.py", line 285, in create_plugin_ui
            return await self._stub.call('CREATE_PLUGIN_UI', self._session_id, player_id, node_id)
          File "/home/pink/noisicaa/build/noisicaa/core/ipc.py", line 455, in call
            raise RemoteException(self._server_address, response[4:].decode('utf-8'))
        noisicaa.core.ipc.RemoteException: From server /tmp/noisicaa-20180330-173955-12839-pc15ov6v/project.299137cfc7b84addaeffae4eadc4139a.sock:
        Traceback (most recent call last):
          File "/home/pink/noisicaa/build/noisicaa/core/ipc.py", line 255, in handle_command
            result = await handler(*args, **kwargs)
          File "/home/pink/noisicaa/build/noisicaa/music/project_process.py", line 426, in handle_create_plugin_ui
            p = session.get_player(player_id)
          File "/home/pink/noisicaa/build/noisicaa/music/project_process.py", line 68, in get_player
            return self._players[player_id][1]
        KeyError: None

* Parallelize tests                                                                   :TESTING:FR:
- memory growth when running all tests is way too high
- run pylint in a subprocess again
- to make tests faster again, run tests in parallel
- for each test, dump results into files (unittest, pylint, mypy, coverage)
  - what std formats are there?
  - libraries to load/merge/report?
- merge results from all tests at the end
- collect logs, stdout/err for each tests into separate files
- is mypy cache safe for concurrent usage?

* memoryview stubs don't know about cast()                                           :TESTING:BUG:
- doesn't know that view[i] = float works

* PyQt5 stubs declare signals incorrectly                                            :TESTING:BUG:
- declared as methods, should be some object with connect/disconnect methods.

* Debug console                                                                               :FR:
- make switching between toplevel windows work properly
  - highlight active window
  - tab to switch
- collapse/expand windows
- process list
  - process information popup
    - cmdline, etc. (whatever psutil gives)
  - show threads per process?
  - display as many entries as we have space
    - enable scrolling, if more
- log viewer
  - filter by pid, logger, regex
  - incremental search
  - in __populate, keep cursor near the previous position

* SampleTrack: crash when rendering                                                        :CRASH:
        Traceback (most recent call last):
          File "/home/pink/noisicaa/build/noisicaa/core/ipc.py", line 254, in handle_command
            result = await handler(*args, **kwargs)
          File "/home/pink/noisicaa/build/noisicaa/music/project_process.py", line 354, in handle_command
            result = self.project.dispatch_command(target, cmd)
          File "/home/pink/noisicaa/build/noisicaa/music/project.py", line 773, in dispatch_command
            result = super().dispatch_command(obj_id, cmd)
          File "/home/pink/noisicaa/build/noisicaa/music/project.py", line 498, in dispatch_command
            result = cmd.apply(obj)
          File "/home/pink/noisicaa/build/noisicaa/music/commands.py", line 237, in apply
            result = self.run(obj)
          File "/home/pink/noisicaa/build/noisicaa/music/sample_track.py", line 131, in run
            tmap = audioproc.TimeMapper()
          File "time_mapper.pyx", line 27, in noisicaa.audioproc.public.time_mapper.PyTimeMapper.__init__
        TypeError: __init__() takes exactly 1 positional argument (0 given)

* Redesign settings handling                                                                  :FR:
- requirements:
  - all settings should be overrideable with flags
  - settings can be passed in for tests to make them predictable
  - listener system, so different components can react to settings changes (and the component
    changing a setting doesn't need to know who uses it)
  - flags override config file, but changes are not persisted
- questions:
  - do settings changes need to be propagated across processes?
    - then they should be managed by some process (ProcessManager?), with other processes listening
      for changes
    - or does UI process own the settings and updates other processes as needed (i.e. tell node_db
      about changed search paths explicitly).
- autogenerate cmdline flags from settings class
  - meta flags:
    - --config=/path/to/config.pb
- store settings as ascii protobufs
- layers:
  - DEFAULT: hardcoded defaults
  - SYSTEM: system-wide config file ($INSTALLROOT/etc/noisicaa/config.pb)
  - USER: user config file (~/.noisicaa/config.pb)
  - FLAGS: cmdline flags
- settings dialog updates user config
  - but those changes must not be shadowed by cmdline flags
  - setting a config value clears it in the FLAGS layer, stores in USER layer.

* Settings: what to do on startup                                                             :FR:
  - start with open dialog
  - start with new project
  - start with previously opened projects
  - remove --start-clean flag (if needed, rm ~/.noisicaa/settings before starting app)

* Testcases for builtin csound processors                                                :TESTING:
- for $DATADIR/csound/*.csnd
- automatically set up buffers, fill with data
- should be usable for other types of processors
- how to verify that output is sensible?
- some *_test.def file along the *.csnd files?
  - list of test cases
  - specify what goes into the input buffers
    - audio: constant value, noise, ...,
    - control: value
    - event: ?
  - specify what to expect in output buffers
    - same as input x
    - constant value
    - non-zero

* Gracefully handle Processor::setup() failures                                               :FR:
* Use a single protobuf for audioproc status updates                                     :CLEANUP:
- PipelineNotification
- pipeline, player, node status updates and perf data
- and a single IPC call to post it to clients
- clients must subscribe to the updates that they want to receive

* Make Slot thread-safe and lock-free                                                         :FR:
- emit() might be called from any thread, incl. the audio thread
- either way there needs to be a lock-free queue that transfers state changes from the audio thread
  into the non-realtime world (so it can then be pushed into the event loop).
- alternatively:
  1) make Slot thread-safe, but not lock-free
    - put lock-free queue into Processor that calls emit() from a non-realtime thread.
  2) require strict phases:
    - setup: only connect() can be called
    - runtime: only emit() can be called
    - cleanup: only disconnect() can be called
    Then emit() does not need to acquire a lock
- OTOH processor state changes in the audiothread are probably catastrophic events anyway, so
  taking a lock does cause any more damage either.

* Demangle function names in stacktraces                                                      :FR:
* Denoise build output                                                                   :CLEANUP:
- get rid of all compiler warnings
- only dump csound output if it failed.

* Slot::Listener should disconnect on destruction                                        :CLEANUP:
So I don't have to manually disconnect when descructing the owner.
Also foo_listener.disconnect() looks nicer than foo_slot.disconnect(foo_listener).

* LV2 UI: implement data-access feature                                                       :FR:
* redesign plugin handling                                                                    :FR:
* Plugin UI slows down after turning the wheels a lot                                        :BUG:
* gracefully handle crashes of plugin host processes                                          :FR:
  - reuse BackendManager?
  - notify UI on processor state changes (careful, when change happens in audio thread).
  - needs async processor states?
    - schedule async CLEAN when processor crashes

* Switch back to vanilla lilv                                                            :CLEANUP:
Implement UI feature query with the generic RDF API:
https://github.com/drobilla/lilv/pull/5#issuecomment-365869585

* Replace ipc.ConnectionClosed by core.ConnectionClosed                                  :CLEANUP:
* Subprocesses should commit suicide then the parent process dies                            :BUG:
When process manager dies hard and doesn't cleanup properly
https://stackoverflow.com/questions/284325/how-to-make-child-process-die-after-parent-exits

* Improve core.Thread                                                                         :FR:
- Add the boilerplate for
  - telling the thread to quit
  - waiting until the thread is ready
  - simple way to re-raise an exception in the thread in the main event_loop.
- StatefulThread?

* Use core.Thread instead of threading.Thread, where it makes sense                      :CLEANUP:
* properly prepare atom output buffers                                                       :BUG:
- apparently an atom output buffer prefilled with a blank atom denoting the size of the buffer.
  - where is that documented?
  - size with or without atom header?
  - any specific atom type?

* support zynaddsubfx
- required features:
  - http://lv2plug.in/ns/ext/worker#schedule
  - http://lv2plug.in/ns/ext/options#options
- atom input port
- how to load instrument w/o UI?
* Native UI support
- implement portNotification property
- look into extension data provides by UIs
- pass port value changes from audioproc process to UI
  - for every block cycle or rate limited to Xfps?
* LV2 features
- plugins with unsupported features:
  - include in NodeDB, but mark as non-functional, with reason text?
- provide features
  - which ones are most common?
  - http://lv2plug.in/ns/ext/worker/worker.html
    - http://lv2plug.in/ns/ext/worker#schedule
  - http://lv2plug.in/ns/ext/options/options.html
    - http://lv2plug.in/ns/ext/options#options
  - http://lv2plug.in/ns/ext/buf-size/buf-size.html
    - http://lv2plug.in/ns/ext/buf-size#fixedBlockLength
    - http://lv2plug.in/ns/ext/buf-size#boundedBlockLength

* Use protobuf for BackendSettings                                                       :CLEANUP:
* Subprocesses should always shutdown cleanly                                            :CLEANUP:
- notify manager before entering cleanup method
- set SubprocessHandle.state = STOPPING
- manager doesn't try to kill it, while in STOPPING, until some timeout passes

* Disentangle audioproc code                                                             :CLEANUP:
Convert as much as possible from noisicaa.audioproc.vm.engine to pure Python
- Make more use of PyFoo wrappers, instead of directly using C++ objects.

Clarify responsibilities of
- AudioProcServer
- PipelineVM
- VM

* Use ProcessManager in unittests                                                        :CLEANUP:
- single CREATE_PROCESS(cls, ...) command
- ProcessManager.add_process_class(cls, run_inline:bool, singleton:bool, ...)

* NodeDB should use separate subprocess to analyze plugins                                    :FR:
- at least LADSPA requires dlopen'ing an .so file, which is dangerous
- if subprocess crashes, mark the plugin as broken
- reuse the same subprocesses, until done or it crashes (and the spawn a new one)

* Allow project specific block_size/sample_rate                                               :FR:
ProcessorIPC does resampling and buffering to translate it to main engine.
* runtests crashes on some module if DISPLAY is not set                              :BUG:TESTING:
- noisicaa.ui.pipeline_graph_view_test
- noisicaa.ui.plugin_ui_process_test

Probably related to unittest.UITestCase

* runtests: disable gdb, if stdout is not a tty                                       :FR:TESTING:
* Export midi inputs as sources in root realm                                                :BUG:
- instrument library routes selected port to its instrument
- how to deal with MIDI channels
  - one port per channel?
  - tell instrument which channel to listen on?
  - put a channel filter node between source and instrument?
- how to deal with devices added/removed?
  - create nodes for each device as they come and go?
- how to implement virtual piano?
  - events needs to be routed from the UI to the backend
* Make the audio thread real-time safe                                                        :FR:
- no more python code in the main loop
- lock-free queue for log messages
* clean up mypy issues in mypy: loose files                                      :CLEANUP:TESTING:
- wc -l $(grep -l -r 'mypy: loose' noisicaa/ | grep -Ev '~$') | sort -nr
- slower: bin/runtests --tags=mypy --pedantic=true 2>&1 | sed -ne '0,/= mypy report =/!p' | grep -vE '^\s*$' | sed -e 's/:.*$//' | sort | uniq -c | sort -nr
- pick some file and clean it up.
- until grep finds no more files.

* Exlore pytest as a better unittest framework                                  :RESEARCH:TESTING:
- https://docs.pytest.org/en/latest/
- supports parallel test execution with pytest-xdist

* Add UI tests                                                                  :RESEARCH:TESTING:
- any framework to use for testing Qt apps?
* Revisit source directory structure                                                    :RESEARCH:
- move all sources into src/
  - can't accidentally import modules from source
- have test in tests/
- what about noisidev?
- tests run against the installed packages (or from build)
  - what about test modules that needs building (cython)?

* Handle async calls using a "queue pump"                                                :CLEANUP:
- separate class
  - items to publish are pushed onto a queue
  - setup creates an async 'main' task
  - 'main' task fetches items from the queue and publishes synchronously
- on cleanup:
  - set lameduck flag
  - inserts into queue will fail
  - 'main' task works off queue, exists when empty
  - wait for 'main' task
  - get result from 'main' task (to collect any exceptions)

* 3rdparty setup.py downloads source, even if it doesn't need to build it                :CLEANUP:
- 'pip install' unconditionally calls 'setup.py install' on all 3rdparty packages.
- 'build' runs in a fresh temp dir everytime(?), so everything is triggered.
- 'install' then sees the sentinel file and is a no-op

- move all steps into 'install', guarded by the sentinel file?
- better: make pip know that the version is already installed and skip it altogether?
  - then the sentinel file would be needed

* Improve project rendering                                                                   :FR:
- persist most recently used path and settings.
- presets for RenderSettings.
- more formats (aiff, ...).
- pass total duration in samples to ffmpeg, so it can set the headers correctly.
  - at least WAVE needs that.
- support dithering?
- set metadata (as supported by each format).
  - at least some "Produced with noisicaä"
- compute ReplayGain value and write to metadata
  - https://en.wikipedia.org/wiki/ReplayGain
- shut down normal player while rendering is active?
  - frees up some memory...
- after successful rendering, add 'Open' button, which should open it with standard app for
  that type.
  - 'Open with...' drop down?
  - 'Open directory in file manager'
- placeholders in file name
  - $(project_name), $(sample_rate), ...
* Speed up project setup                                                                      :FR:
- takes quite some time until a project is up and running.
- figure out what the bottlenecks are.
  - a lot of messages are passes around. Anything that can be batched.
  - how much time is the logging taking up?
- Batch set_control_value when initializing a node
  - some nodes have a lot of control values...

* No cleanup in destructors                                                                  :BUG:
- Was a bad idea: http://www.artima.com/cppsource/nevercall.html
- Code that deletes something must explicitly call cleanup() before.
- Destructor should assert that the object has been properly cleaned up.
- or: Get rid of the cleanup() methods and just do the cleaning up in the destructor.
  - Any reason why I should call cleanup without destroying the object?

* Unclean shut down                                                                          :BUG:
Sometimes still hangs on shutdown. Subprocess calls _exit(), but manager doesn't seem to get the
SIGCHLD. Non-deterministic and rare, so hard to debug...

* Crash when opening second project                                                        :CRASH:
ERROR   : 8298:7fbd9ef37700:ui.editor_app: Exception in callback: Traceback for <Task finished coro=<BaseEditorApp.openProject() done, defined at /home/pink/noisicaa/build/noisicaa/ui/editor_app.py:253> exception=AssertionError()> (most recent call last):
          File "/usr/lib/python3.5/asyncio/tasks.py", line 293, in _step
            self = None  # Needed to break cycles when an exception occurs.
          File "/home/pink/noisicaa/build/noisicaa/ui/editor_app.py", line 256, in openProject
            await project_connection.open()
          File "/home/pink/noisicaa/build/noisicaa/ui/project_registry.py", line 75, in open
            await self.create_process()
          File "/home/pink/noisicaa/build/noisicaa/ui/project_registry.py", line 71, in create_process
            await self.client.setup()
          File "/home/pink/noisicaa/build/noisicaa/music/project_client.py", line 93, in setup
            await super().setup()
          File "/home/pink/noisicaa/build/noisicaa/music/project_client.py", line 69, in setup
            await self.server.setup()
          File "/home/pink/noisicaa/build/noisicaa/core/ipc.py", line 177, in setup
            stats.Counter, stats.StatName(name='ipc_server_bytes_sent', server=self.name))
          File "/home/pink/noisicaa/build/noisicaa/core/stats/registry.py", line 45, in register
            return stat
        AssertionError

* Explore https://github.com/census-instrumentation for stats tracking                  :RESEARCH:
* Make playing notes on insert when editing work again                                       :BUG:
Reimplement Player.send_message() again, now without the proxy, forwarding the message directly
to the backend.

* Explore the usefulness of a CommandContext                                            :RESEARCH:
- Pass around a CommandContext reference, which collects async tasks. At the end of its
  lifetime, it waits for all pending tasks to complete (i.e. it can only be created/destroyed
  in a coroutine).
- IPC server creates the main context for each command
- Subcontexts for specific sections where async tasks should complete before leaving the
  section.
- Could also be used to collect actions that should be sent out in a batch at the end
  (e.g. project mutations).
- Setting properties has no way to set the context object.
  - Track the context in the project object.
  - We assume single-threading, so it's safe (but ugly) to use this 'kinda' global variable.

* Base class for processor_*_test.pyx                                                    :CLEANUP:
- setUp()/tearDown() to handle all the boilerplate (HostData, TimeMapper, ...).

* Handle crashes of audio process gracefully again.                                           :FR:
- audio process refuses to restart, because fifo file already exists.
  unlink before opening?
- project process sends audioproc address when audio process starts up.
- IPC node and UI must gracefully handle dead connection to audio process and wait for new
  address when it gets restarted by the project
  - should they notify the project, or will it always notice on its own, when the audio
    process is dead?
  - can this logic be hidden in the ProjectClient?
- music.Player notifies client (UI) of audio proc address, after process was started
- music.Player keeps track of current PlayerState, and re-applies it, if backend restarts

* Rework how time signatures are managed                                                     :BUG:
- Currently duration is a property of Measure. It uses the time signature of the measure in the
  property track at the same index.
  - it references the property measure with its index within the measure_heap, which is basically
    a random number. Can cause crashes when pasting a sequence of measures.
  - the same measure could be used at different positions with different time signatures.
- time signature is not shared across tracks.
  - each track can have a different time signature and change it at arbitrary positions.
  - measures do not align vertically.
- how to deal with selecting a block of measures across tracks, if the measures don't line up
  vertically?
- the TimeLine should show marks for the current track.
- simplify how to set time signature across multiple tracks.
  - should be the default, with some extra step to have a different time signature on certain
    tracks.
- Set # measures dialog has list of tracks, select which tracks to affect
* Cleanup message passing                                                                :CLEANUP:
- which types of messages exist
  - UI to project (player commands, ...)
  - UI to audioproc processor (note on/off events to the track's 'source' node)
  - project to UI (player state changes, playback pos updates, ...)
  - project to audioproc VM (player commands, ...)
  - project to audioproc processors (sync model changes, ...)
    - AudioProcClient.send_node_message()
  - audioproc VM to (player state changes, playback pos updates, ...)
  - audioproc processors to project (notifications, ...)
- unify the different ways.

* Use __builtin_expect() to optimize conditions in vm                                    :CLEANUP:
E.g. use unlikely() when checking for error conditions.
Is there some cross-compiler/-platform header to provide this functionality?

* track syscalls in audio thread                                                      :FR:TESTING:
- seems non-trivial:
  - ptrace can trace just a specific thread, but it must be in a subprocess of the tracer.
  - calling ptrace() with the gettid() of the thread fails with EPERM
  - perhaps move the tracing into the ProcessManager itself.
    - every spawned process is being ptrace()'ed
    - use ptrace to manage process state (instead of SIGCHLD)
    - track processes/threads created by all processes
    - can request syscall tracing for a specific pid (which could be a tid)
    - have a flag --strace-all to enable syscall tracing for all processes.
    - no fast way to selectively disable tracing for expected syscalls -> no way to make this
      real-time friendly, so only enable it for debugging
  - some experimental code in playground/syscall_tracer.py

* Evaluate performance of exceptions vs. Status returns                                 :RESEARCH:
- build test case
- compare
  - Status with -fno-exceptions
  - Status without -fno-exceptions
  - Exceptions
  - Case without exception raised/error status
  - Case with exception raised/error status

* Consider switching the build system                                                   :RESEARCH:
- cmake is nice for C++, but quirky for non-C++ stuff
- https://waf.io/
* Improve ArrangeMeasuresTool                                                                 :FR:
- remove selection when switching away from tool
- Use QClipboard
  - does it make sense?
    - only for copy/pasting between projects
  - also for selection? support middle-click insert?
- select multiple measures
  - click first and shift click end
- cut: either remove or clear selection
- paste: either insert or overwrite
- drag'n'drop move, copy, link
- allow selection spanning different tracks
  - what about control/sample tracks?
    - just skip for now
    - first implement selecting measures for those track types
- Linked measures                                                                             :FR:
  Dereference: clone the pointed to measure and replace link with that copy.
  If a group of linked measures is selected, only make one copy and link the
  rest. E.g. A B A' B' [A' B' A' B'] -> A B A' B' C D C' D', where C=copy(A),
  D=copy(B).
  Explicit dereference all to create standalone clone for every selected
  measure.
* Edit notes tool                                                                             :FR:
- move notes up/down
- change duration

* ProcessorCSoundBase must handle csound_{orchestra,score} parameter changes at runtime      :BUG:
* Remember selected tool in session                                                           :FR:
* Rendering of edit actions                                                                   :FR:
- separate modelstate object with generator interface for model state
  - produces PaintAction objects
    - attrs: id, state, bbox
- renderer takes modelstate object to paint
- activity object proxies modelstate and modifies it to reflect an in-progress edit action
  - e.g. change position of a moved note, etc.
  - avoid deep copy of modelstate
- tool creates/deletes/modifies activity object
- limit updates to changes bbox? how?
  - keep map of (id, state) -> bbox
  - compare set of keys with current PaintActions, any addition/removal is added to the
    current dirty rect.
  - then only execute PaintActions that intersect with dirty rect.
  - needs two passes over list of PaintActions
* Continuous score/beat tracks?                                                          :CLEANUP:
- don't split track into measure objects
- pros
  - simplifies actions/rendering across measure boundaries (moving notes, ties, ...)
- cons
  - how to do linked measures?
  - have arbitrary length regions?
  - just as complicated as measure objects?
- compromise:
  - keep measure objects in the model
  - don't create MeasureItems at the UI level, move all logic into TrackItem
- handle all track type like that?
  - allow measure-wise copy&paste of control/sample tracks
  - select, cut, copy, paste arbitrary regions
    - automatically insert control points/split samples at selection boundary
  - selecting measures is just a special case of this
* Some builtin instruments                                                                    :FR:
- Have set of reasonably sounding instruments builtin.
- Remove dependencies on *-soundfont-* packages.
- Use those for demo projects
- Also remove dependency on mda-lv2 and swh-plugins packages from demo projects

* Don't use system files in tests                                                :CLEANUP:TESTING:
- grep for '/usr/'
- build test ladspa plugins from source in testdata

* Full app run in vmtest                                                              :FR:TESTING:
- bin/noisicaä --play-and-exit --demo="demo name"

* Track properties should directly modify mixer control values                           :CLEANUP:
- drop track mixer properties muted, gain, pan
- route mutations back to Track instance, so UI can install listeners without knowing about
  mixer node.

* Track VU Meter                                                                              :FR:
- track_mixer has krate output ports (left & right)
- route control values back to UI
- simple rms, or something better?

* Turn VM loop inside out                                                                :CLEANUP:
- backend owns the loop
- can either spawn a thread to run the loop, or execute the VM from a callback

* Make sample rate configurable                                                               :FR:
- all processors need to cleanup/setup on changes
- if sample_rate is a property of HostData, can renderer use a different sample_rate than normal
  playback?
* Cleanup temp files on shutdown                                                              :FR:
- still leaves a dead directory around on unclean shutdown, SIGKILL, etc.
  - put in /tmp and rely on OS to cleanup junk
  - on startup try to find dead directories and clean them up
    - take a lock, which is automatically released by OS
- some unittests create projects in /tmp
- runtests leaves directories behind, when it's interrupted

* crash on shutdown, when csound wants to log after LogSink has been destroyed             :CRASH:
- is HostData properly cleaned up?
* turn off all notes when playback gets paused						      :FR:
* Sections on the timeline                                                                    :FR:
- have different regions in time within the project, e.g. for experiments, etc.
  - tracks can be discontinuous, i.e. measures don't need to line up
  - each measure tracks its position in time
  - set regions in the time line.
  - inserting measures only shifts measures to the right within the current region
    - if the end goes past the region, extend the region and move all following regions (across
      all tracks) to the right to make room.

* Finish VM-based pipeline engine 							      :FR:
- port parameters
  - volume, mute, bypass, dry_wet
  - bypass needs conditionals
- lv2 features
  - make atom buffer size a param of hostsystem
- ProcessorFluidSynth
  - capture fluidsynth logs
  - cache soundfonts in master instrument again
  - sample precise scheduling of events once at the start of a block?
- Put a lockfree queue between C++ logging and Python logging
  - only need that in the performance thread...
  - thread local LogSink?
- capnp API is really awful. strongly consider rolling a custom format for FrameData
  - are there any other places, where I care about zero-copy deserialization?
- clean use of NodeDescription types
  - which types are actually needed?
- engine_perftest should focus on other opcodes than CALL
- use this pattern for C-only classes
  https://github.com/cython/cython/wiki/FAQ#can-cython-create-objects-or-apply-operators-to-locally-created-objects-as-pure-c-code
- player_integration_test with null backend
  vm thread seems to saturate CPU, doesn't let main thread handle pipeline_status messages.
  When turning pipeline down, queued messages cause lots of errors.
  - make sure to flush messages out before shutting down
- use protos for PipelineMutations instead of pickled objects.
- better test coverage
  - base class for node unittests
- buffer conversion methods?
  - different buffer types for events (native, atom, ...)
  - auto convert as needed

* Use https://abseil.io/blog/								 :CLEANUP:
- absl::Substitude for sprintf
- absl::string_view for method args
- absl::GetCurrentTimeNanos() for PerfStats
* ProcessorFluidSynth									      :FR:
- sample precise scheduling of events once at the start of a block?
* ProcessorCSound									      :FR:
- use block size for ksmps
- allow any ksmps with block_size % ksmps == 0
* Improve CMakeLists.txt                                                                 :CLEANUP:
- Use CMAKE_BUILD_TYPE to set the right compiler flags
- autogenerate dependencies for .pyx, .proto files.
- don't make every file a separate target
  - does that make the build faster (if just a few files changed)?
  - single target for each python package
  - target depends on .py, .so, etc. files, plus rules to generate from src
    - have macros:
      python_module(foo) -> foo.py
      cython_module(foo) -> foo.so
      etc. for pb, capnp, ...

* Built-in testcases                                                             :CLEANUP:TESTING:
- for each file generate a built-in TestCase
  - run some C++ linter and iwyu on *.cpp/*.h files.
* Improve mypy checking                                                                  :TESTING:
- adding manual .pyi files for every .pyx is cumbersome...
  - any way to automate that?
- require type annotations

* Get pycheck working                                                           :RESEARCH:TESTING:
- seems much faster than mypy
- problems:
  - no documentation
  - requires python2.7, so can't be installed in the venv
  - not installable via apt either
  - doesn't find typeshed on its own, need to set TYPESHED_HOME
  - needs --python_version=3.5 --python_exe=/usr/bin/python3.5
    - crashes if it uses the python exe from the venv
  - complains about super()

* Reduce duplication in noisicaa/music/*_test.py					 :CLEANUP:
- create TestProject class
  - has dummy node_db (with builtin stuff and selected other stuff)

* Capture per-node logs									      :FR:
- csound, lv2 log extensions, ...
- logs tab in node IU
* Improve noisicaa.core.stats_test                                               :CLEANUP:TESTING:
The module's code changed a lot, but the unittest wasn't updated.

* Loop start/end move around when BPM is changed					     :BUG:
because they're tracked in sample time, not music time
can also cause crashes on BPM changes, if loop marker go out of range

* ProjectDebugger: list command log 							      :FR:
* ProjectDebugger: create new snapshot 							      :FR:
* ProjectDebugger: purge command log 							      :FR:
* Watchdog for pipeline thread								      :FR:
- pipeline thread increments counter on every iteration
- watchdog thread checks counter
- if not incremented for N * blocksize / samplerate, SIGABRT the process
* List of recently opened projects							      :FR:
use xdg function to store projects
http://pyxdg.readthedocs.io/en/latest/recentfiles.html

* Node presets										      :FR:
- track current directory for import/export file dialogs
  - which default directory?
- which file extension?
- serialize port list (if editable)
- serialize param descriptions (if editable)
- add to nodedb
  - nodedb scans preset directory
  - store presets in $HOME/.noisicaä/presets
- node remembers preset it was created from (or saved to)
- UI
  - save as
  - save (if linked to preset)
  - load from preset
    - select from all presets for this node URI
  - import/export
    - load/save to arbitrary paths
  - edit metadata
- metadata
  - open "edit metadata" dialog on "save as" or "export"
  - author
  - copyright
  - license
  - comment
* Rework player position tracking							      :FR:
** Set loop range on UI
- clear loop
- drag loop markers
* Port groups										      :FR:
** Audio ports are single channel
** PortGroups group a set of channel with role identifier (left, right, ...)
** Connecting port groups implicitly connect matching ports in the groups
** LV2 spec: http://lv2plug.in/ns/ext/port-groups/port-groups.html
** UI prefers showing port groups instead of individual ports, option to ungroup ports
** Implicit coercing of mono->stereo ports

* Message router									      :FR:
- Send messages to ports, which might live in another process.
- Ports have a unique ID within its process.
- Port address is (process ID, port ID).
- Messages to other processes are sent over IPC channel.
- Process's IPC server routes message to local port.
- IPC server address can be queries from ProcessManager.
  - Create stubs on demand?
- RPC are implemented as request/reply pair with a unique RPC id.
  - RPC client tracks set of outstanding RPC, by RPC id.
* stats module										      :FR:
- graph rendering slows down UI
- label stats with process name
- operations
  - aggregate functions
    - sum, min, max
  - rate over interval
  - mean over interval
- StatMonitor:
  - history
  - presets
  - time axis
    - render
    - select range
  - key
    - different colors per graph
    - show non-common labels
     - latest values
  - vertical range
    - round min/max
    - render grid
  - correct rendering along x axis
    - map timestamps to x position
    - interpolation
* ipc.Server: shutdown waits for outstanding commands to finish				     :BUG:
- could crash in ServerProtocol.command_complete, if Server instance has already been cleaned up
- does it need to lameduck?

* Editor: show/hide tracks does work anymore                                                 :BUG:
* ScoreEditorTrackItem: Improve rendering						      :FR:
** ghost notes should be closer to real insert position
** squeeze notes into measure, if duration is exceeded
** render exceeding notes differently
** proper chord rendering
** note beams
** use http://www.smufl.org/?
- fonts & data files: https://github.com/musescore/MuseScore/tree/master/fonts
* Exception when reordering tracks 							   :CRASH:
Traceback (most recent call last):
  File "/storage/users/pink/projects/noisicaä/noisicaa/ui/tracks_dock.py", line 499, in onCurrentChanged
    not track.is_master_group and not track.is_first)
  File "/storage/users/pink/projects/noisicaä/noisicaa/core/model_base.py", line 410, in is_first
    raise NotListMemberError(self.id)
noisicaa.core.model_base.NotListMemberError: 32e1b62e20524d16a584c65311960356

* when changing scale_x, keep view centered on current position				      :FR:
* use libsndfile									      :FR:
- instead of custom WAVE parsing

* Audio tracks										      :FR:
- rendering
  - transfer whole, decoded sample to UI
  - do all rendering UI side
- don't use a normal command, make it a special call
- drag'n'drop sections onto audio tracks
- a section is a clip or range of a clip
- per section envelope
  - short (few msec) ramp up/down to avoid clicks
- manage list of samples owned by sheet
- garbage collect unused samples
- handle samples with different sample rate
  - resample at playback
  - or resample full sample at playback and cache result
  - or resample full sample when importing it
- mono/stereo tracks
  - select when creating track
  - mono samples can be placed on left, right or both channels
  - stereo samples are downsampled on mono tracks

* Pan node										      :FR:
- left/right
* Store IDs of pipeline graph nodes in track						 :CLEANUP:
- refs from PipelineGraphNode should use IDs, too

* More flexible instrument handling							      :FR:
Remove disappeared instrument in full scan
- track set of touch instruments
- instruments not touched after scan are obsolete

Use display_name in track_property_dock
- query instrument_db for description
- fallback to URI, if description not found

Async scanning
- UI installs listener to get updates when InstrumentDescription of an URI changed
  - InstrumentDBClient also calls 'mutation:$(uri)' callback
  - TrackItem and TrackPropertiesDock

Full vs. incremental scans
- report scan progress to clients

Deep scanning
- instrument type, mtime
- sample_scanner:
  - any metadata (copyright, ..) in common headers? iXML?
- soundfont_scanner
  - fields from soundfont.py
  - audio format data (#channels, sample rate, sample format)?

Handle file moves
- store file checksum
- when same checksum with different path detected, then...?
  - custom attributes are keyed by checksum?

Organize library
- add custom attributes to instruments
  - star items
  - tags
  - comments

Add individual files
- dialog or filesystem browser in the UI?
- integration with external sources (freesound.org, etc.)?

Library UI
- keep list sorted
  - when inserting new items, sort by display_name
  - how to do that O(log n)?
- icon for instrument type
- filter lists by
  - tags
  - only starred
  - mono/stereo
  - sample rate (range)
  - sample format
- edit multiple entries
  - add/remove tag/star
- view as tree by
  - path
  - tag
- query DB if selected file is up-to-date
  - show "File has changed, rescan" button
  - install listener on URI to update info fields when changed
- keep list in sync added/removed files
- menu
  - Incremental scan
  - Full scan
- status bar with progress while scanning
  - when finished: Library scan finished XX ago: %d added, %d removed, %d updated
  - status is tracked by app
    - status:
      - 'init_scan', #files_found
      - 'scanning', #files_done, #files_total
      - 'done', done_timestamp, #inst_added, #inst_remove, #inst_updated

* Session state										      :FR:
- store binary log for efficiency
- replay log on open
- checkpoints

Stores
- have std handlers to connect a widget to UI state
  - when connecting, should set values from session
  - sets up listeners to sync widget state to session
  - QTabWidget
- pipeline node enabled state
- track/node mute/solo/visible states
- current track

* Gracefully handle pipeline crashes							      :FR:
Blacklist crashing nodes
- user can manually reactivate node
- directly mark node as broken, when it throws an exception during setup() or run()
- when building initial state, mark nodes as broken from session state.
- also send error message to UI
  -> or pull with player.get_node_state(id)?

* InstrumentLibrary: remember the selected MIDI source					      :FR:
* Fix removing measures									     :BUG:
- remove measure on SheetPropertyTrack causes exception
- no way to remove trailing measures from sheet

* Unify instrument handling in ScoreTrack and BeatTrack					 :CLEANUP:
* Review licenses of all used modules							      :FR:
All compatible with GPL?
* SampleInstrument: tuning								      :FR:
Set the base tuning of the instrument.
- also look at sample rate (ftsr function)

* Control tracks									      :FR:
Any controllable value can be turned into a control track.
Icon next to controllable values, drag'n'drop onto editor.

- should control tracks be measured?
  - if not, inserting a new measure across all tracks becomes non-obvious
  - if not, layouting needs to be reimplemented
    - each track has its own layout
    - but measures should still align
  - control tracks should still be rendered as a sequence of measures,
    aligned to the other tracks
  - if yes, moving control points across measure boundaries becomes
    non-trivial
- what happens when the song becomes shorter than a control track?
  - discard all control points past the end
    - clip last segment correctly?
  - or keep control points, but just don't show them
  - or keep track length
- splines?
- free hand
- properties
  - min/max
  - linear/log
  - unit (Hz, dB, %, ..)
- display current value under cursor position
- edit track properties
- implicit first and last segment
  - extend current value from start or end
- ControlEntitySource: compute value at a-rate

* ToolDock: track specific tool set							      :FR:
- active track:
  only the active track gets edit events. clicking on another track makes
  that track active and changes the set of tools and the active tool.
- remember active tool per track type
- could also activate track by enter events
  - but if mouse then moves to tracks dock, it might cross other tracks causing confusion
* Default track effects									      :FR:
When creating new track, insert standard set of effects in pipeline.
Default effects to bypass.
Reverb, Delay, Pan, Equalizer.
Or build effects into Mixer node?
* Pipeline: don't execute unused nodes							      :FR:
Skip node's run(), if all its outputs are bypassed.
Skip node, when there are no unmuted upstream nodes. Pass this on, to disable complete subtrees.
* Mixer strip										      :FR:
Create mixer panel for each track.
Add controls or monitors with drag'n'drop.

* Reparent mixer nodes when moving tracks between groups 				     :BUG:
When reparenting a track, also reparent its mixer node.

* turn any node parameter into a control input port					      :FR:
- ports can be added and removed on the fly
- parameter description has sufficient data to describe port
- parameter is always a-rate in csound

* Exception when closing a project 							     :BUG:
- 'dict_values' object is not an iterator
- no traceback?

* Most instruments should produce mono data						 :CLEANUP:
* Abstract base class for ui mixins							 :CLEANUP:
- to make pylint happy

* Revamp object model									 :CLEANUP:
- root manages heap of objects
- when creating object, add it to heap
  - __init__ needs to know root, so it can create children
  - or separate setup() method?
- all object references (child, lists, etc.) only store IDs in state, do
  lazy dereferencing on __get__
* BeatTrack: move beats to arbitrary positions						      :FR:
* Sometimes hangs during shutdown							     :BUG:
Last sign of life:
  INFO    :18195:7f91c16bc700:ui.editor_app: Shutting down.

* ScoreMeasure: correctly render key signature changes                                       :BUG:
Must render naturals for all accidentals that we active in previous measure.

* More precise playback timepos reporting						      :FR:
Currently the UI is behind a bit because of buffering in the pyaudio backend.
- Backend in main audioproc pipeline has a callback that reports the timepos of the block actually
  sent to the driver.
- IPCNode listens on that and forwards to the player's IPCBackend.
- IPCBackend applies timepos_offset and reports back to Player.
- Player sends timepos to UI.
- Player needs a list of stream->sheet time mapping to get correct offset.
  Add entry every a time position seek happens

UI polls timepos, instead of player pushing it
- fixed rate of updates
- ensure some min time between each call, so it degrades gracefully, if UI thread becomes overloaded

* Built-in way to split/join channels							      :FR:
- how often do you have to go from mono->stereo or vice versa?
- going through splitter/joiner nodes is too cumbersome
- implicit up/down mixing in Port.collect_inputs?
* Audio pipeline sends data back to UI							      :FR:
- For VU Meters, spectograms, etc.
- Player buffers data frames.
- When player receives the matching timepos from the main pipeline, send buffered data
  to player client.

* Custom csound filter node								      :FR:
- make port list editable
- report csound errors back to UI
  - capture logs while setting orchestra/score
  - needs some mechanism to report events from audioproc pipeline back to UI
- big red button
  - tear down current csnd instance
  - needs some mechanism to send action events to audioproc node
- two engines - new/old code - in parallel, slide from old to new
  - init new code
  - start processing new code , output at 0
  - slide old=100%, new=0% -> old=0%, new=100%
  - stop processing old code
  - clean up old code
  - how does that work with arbitrary output nodes? and events?
- edit widget with syntax highlighting

* cleanup audioproc.Node.__init__ signature						 :CLEANUP:
store node uri

* merge consecutive commands								      :FR:
- keep a single item in-memory buffer before writing commands to disk
- when adding commands to log
  - call prev_cmd.try_merge_with(latest_cmd)
    - command class must be marked as mergable
    - if same class, append mutation log of latest_cmd to prev_cmd?
    - or just handle simple attribute changes, overwriting the target value
  - if returns False, push latest_cmd to log (flushing prev_cmd to disk)

* ScoreTrack: tweak noteon position, duration						      :FR:
- control properties of track
- offset for noteon events
- multiplier of note duration
- probably best to implement after background eventset

* Note fine tuning									      :FR:
Tweak time of noteon/noteoff for each note.
Only active at high zoom levels.

* SIGSEGV when editing PipelineGraphView						   :CRASH:
Possibly caused by the use of QGraphicsEffect for dropshadows?

* NodeDB: start_scan									      :FR:
How to report scan progress back?
First a quick scan to find candidate files?
* NodeDB: set search paths								      :FR:
Manage from settings dialog.
Search path per scanner (csound, ladspa, lv2, ...).
* NodeDB: cache DB									      :FR:
Storage location: $HOME/.cache/noisicaä
Track time of scan
Load cache on startup
Rescan if time of last scan > X
* Run LADSPA plugins at higher rate							      :FR:
So changing control parameters are updated at a fixed rate instead of the backend's frame size.
Do it like csound, call run() with e.g. num_samples=32 until output buffer if filled.

* PipelineGraphView: edit node name							      :FR:
* Track volume/mute properties: change connect trackmixer node instead.			     :BUG:
* Color code tracks and measures.							      :FR:
Tracks: To group e.g. all percussion visually.
Measures: To group thematically related sections.
Popup menu provides palette of color, separate list of already used colors
(to make it easier to answer the question, which shade of green I used
before).

* PipelineGraphView: drop onto existing node to replace it.				      :FR:
Retain properties of the same name from replaced node.
Deny drop, if node is not compatible with existing node.
* PipelineGraphView: drop new node on connection.					      :FR:
Insert node between the connected nodes.
Deny drop, if node is not compatible with connection type.
Reorganize graph to make space for the new node.

* PipelineGraphView: node info in nodes list.						      :FR:
List of ports and their types.
Node description, etc.
* PipelineGraphView: disallow connections that create a cyclic graphs.			     :BUG:
Compute list of valid dest nodes and highlight those.
* PipelineGraphView: scrollwheel zoom.							      :FR:
* PipelineGraphView: drag to move.							      :FR:
* PipelineGraphView: no random jumping around when inserting new nodes.			      :FR:
* PipelineGraphView: multiple selections.						      :FR:
** ctrl-click to add/remove nodes from selection set.
** Way to select all upstream nodes of a node.
** Move nodes together.
** Remove all
* PipelineGraphView: visualize mute, volume, bypass state in UI				      :FR:
* PipelineGraphView: select port or connection filters node list to compatible nodes	      :FR:
* ScoreMeasure: improve rendering for different zoom levels				      :FR:
At low zoom levels, don't render full notes, just dots.

* More instrument types									      :FR:
- SFZ
- arbitrary plugin
* Lens											    :IDEA:
At low zoom levels, click on an area to popup an overlay window showing that area at a higher
zoom level for editing.

* Canvas tracks										    :IDEA:
Free form painting on the track.
Turn into array of a-rate values to feed into instrument.
E.g. each row is an oscillator, row index is pitch, value is frequency.
Do crazy stuff in csound.

* Track freezing									    :IDEA:
- render audio at track mixer, write to file
- replace track with playback of that frozen audio data
- gain/mute on track mixer still works
- also freeze output of all upstream nodes, that are connected to nodes outside of track
- all upstream nodes of track mixer in PipelineGraphView are disabled
- rerender track
- unfreeze track

* notes on the grid									      :FR:
Alternate editing mode for ScoreMeasures.
Insert notes at absolute time positions, recompute duration of preceding note.
Switch with insert/overwrite key?
How to deal with very short notes? I.e. grid too small.
- set grid size based on visual scale, zoom in to get shorter intervals.
What about triplets etc. which are off the grid?
* Undo/redo doesn't replay pipeline mutations						     :BUG:
- trigger pipeline mutations from listeners on model
- don't trigger mutations while replaying log during load
- store pipeline mutations as operations in command?

* use recordfile for command log							 :CLEANUP:
   * need file offset
   * read record from offset
* cleanup and write docstring for storage.py						 :CLEANUP:
* delete unused objects on client side, when						 :CLEANUP:
   * obj prop set to None
   * item deleted from objlist
   * objlist cleared
* make consistent use of __private attributes						 :CLEANUP:
* consistent naming of close()/cleanup() methods					 :CLEANUP:
* replace isinstance(..., model.TrackGroup) with a is_group property			 :CLEANUP:
* non-existing file on cmdline creates project						      :FR:
   * remove + hack

* main process keeps track of project processes						      :FR:
   * opening existing project reconnects to that process

* per process cpu monitor								      :FR:
   * collect cpu time with 1ms precision
   * separate thread
   * send bulk data every O(100) ms to UI
   * plot along pipeline perf chart
* PipelinePerfMonitor: aggregate data over time						      :FR:
- avg duration and std deviation per span.
- how to visualize averaged gantt chart?
* PipelinePerfMonitor: per span graphs
- duration
- start time relative to parent span
- start time relative to frame start

* process stats										      :FR:
   * STATS call to manager
   * name, pid, cpu, memory
   * graphs

* stats for backend buffer length							      :FR:

* project_fuzztest.py									 :TESTING:
   * launch ProjectProcess using same eventloop
   * use inmemory filesystem
   * random actions
      * close and reopen
      * create checkpoint
      * undo/redo
      * player interaction
      * execute all existing commands
      * coverage report
* XML schema for node descriptions							 :TESTING:
   * validate all nodes from library against schema
* parse all csound scripts for syntax errors						 :TESTING:
UI Improvements

* better handling of remote exceptions							 :CLEANUP:
   * traceback
   * every exception crashes
      * Server errors terminate server process
      * traceback sent to process manager, propagate to process owner
      * exceptions in threads terminate process
      * handle simultaneous exceptions in multiple threads

* master volume										      :FR:
if backend supports volume, use that. e.g. set alsa mixer volume.
otherwise set volume on outgoing samples.

* move generic Qt classes to noisicaa.qt						 :CLEANUP:
* LoadHistoryWidget									 :CLEANUP:
* fix left over TODOs									 :CLEANUP:
* remove or fix commented code								 :CLEANUP:
* ServerError and ClientError exception base classes.					 :CLEANUP:
- ClientError is returned to client
- ServerError causes server to crash
* factor out common Client, Process, Session code					 :CLEANUP:
* separate client, server and common code in music					 :CLEANUP:
* proper classes for mutations emitted from state.py					 :CLEANUP:
* move tests from state_test.py to model_base_test.py					 :CLEANUP:
* move initial project mutations to BaseProject						 :CLEANUP:
* node_db imports all nodes and populates itself					 :CLEANUP:
* use registry instance instead of class attributes to track classes			 :CLEANUP:
that allows distinct class hierarchies and is cleaner for testing
music.commands.Command.command_classes
* AudioProcClient should use callbacks for mutation and status distribution		 :CLEANUP:
instead over overriding handle_pipeline_*, client code should register a callback
* base class for audioproc nodes created from a NodeDescription				 :CLEANUP:

* add a concept of "action receivers"							 :CLEANUP:
- EditorWindow has a single object currently being the "action receivers"
  - use Qt focus?
- global actions, e.g. cut, copy, paste, are sent to that object
- if receivers doesn't handle it, pass it on to parent
  - use custom Qt events?

* Guitar track										    :IDEA:
- physical simulation of guitar strings
- edit finger positions
- edit strokes

* Move the various cython bindings to noisicaa.bindings					 :CLEANUP:
* == Post alpha work ============================================================================
** Build binary .deb                                                                          :FR:
- Use https://github.com/spotify/dh-virtualenv?
- Needs working "setup.py install"
- Separate runtime and build dependencies
- vmtest for binary installation with full app run
- host packages on https://help.launchpad.net/Packaging/PPA



* == unsorted nodes from gdoc =================================================

* use URIs to open files
   * always abs path
   * demo://params

* use stats calls to other processes
   * for pipeline utilization
* TracksDock: drag'n'drop to organize tracks
Assorted TODOs
* pass done callback to start_process
* first flesh out AudioProc process
   * prevent cycles 
   * handle node parameters
      * default values for parameters
      * update parameters
         * open dialog
         * mark parameters as mutable
         * client and process methods
   * pass user-data along with commands, pass back to client along with mutations. use for e.g. initial position of nodes when dragging.
   * monitors
      * attach to any input or output port
      * for audioports
         * waveform, vumeter, spectrum
   * system midi event source 
      * one port per channel?
   * support note volume
      * just multiply each audiooutput buffer after run()?
   * race condition in audioproc_client_test.ProxyTest.test_remove_node?
      * occasional "ERROR:noisicaa.audioproc.audioproc_process:PUBLISH_STATUS failed with exception: 'NoneType' object has no attribute 'write'"
* UI state vs. project state
   * UI state:
      * current sheet, track, etc.
      * selections
      * position in view, zoom level, etc.
   * there could be multiple UIs for a project
   * same UI state spans projects
      * window/dock positions, sizes
   * project mutations might affect UI state
      * selected track is removed, etc.
      * undo should recreate related UI state changes
         * undo delete current track -> re-added track becomes current
* cli:
   * subcommands 
      * edit path
      * create path
      * play path 
      * encode path
   * global vs. per command flags
   * move command handlers to submodules
* UI: show on cursor when an operation is not allowed
* UI: press ‘h’ to highlight all locations where the current tool is applicable
* ties/slurs:
   * either: note groups or markers
   * markers:
      * begin, continue, end
      * adding begin/continue marker, adds end marker to next note
      * continue/end marker implies prev note has begin/continue marker
      * note can have multiple markers
         * A(b) B(c,b) C(e,c) D(e):
  
         * should markers have some group_id to identify which slur they belong to?
         * would it be sufficient to just list the group_ids for each slur that a note belongs to? if it’s the beginning/middle/end could be deduced. but that knowledge is handy for rendering and playback
   * groups:
   * track wide list of groups
   * add notes to groups
   * notes have reference to groups
   * find other notes in group requires cyclic references
   * edit flows:
   * click on note that is currently ‘end’
   * becomes ‘continue’, next note becomes ‘end’
   * click on note before ‘begin’
   * becomes ‘begin’, next note becomes ‘continue’
   * click on note that is currently ‘begin’, ‘continue’
   * no-op
* midi
   * MidiHub
   * list keyboards, controls, buttons - not ports
   * route messages to driver
   * drivers
   * generic_midi_keyboard
   * driver configs
   * velocity function (min, max, gamma)
   * octave transpose
   * libalsa
   * more generic DeviceInfo, instead of Client-/PortInfo
* don't leave trash behind, if Project.create fails
* log_dump util
* https://travis-ci.org/ integration
* measure layout
   * align notes across tracks
* proper chord rendering
* ghost note at insert point
   * correct insert position for last note in measure
   * use tinted note instead of transparent
   * http://www.qtcentre.org/threads/53946-Is-it-possible-to-change-color-of-a-QGraphicsSvgItem
* selections
   * select measures & tracks
   * clear
   * transpose
   * cut, copy, paste
* InstrumentLibrary
   * update UIState as changes happen
   * use commands for changing library state
   * persist state
   * main instrument library - where should the state go?
   * track selection dialog: store ui_state under track
* signal buffer underruns
* when muting a track during playback, remove highlighted note
* more efficient layouting
   * measureitem.recomputelayout tells sheet about changes
   * sheet decides which measures need relayouting
   * just update measure positions
* UI: cursor graphics item position should be updated when the view is scrolled.
* UI: better scrolling when following the playback position
   * either smooth scrolling, or jump one measure at a time.
* UI: time/key signature submenus should indicate current.
* USABILITY: Clicking on/editing a track on the sheet should make it the current track
* USABILITY: Better widget for volume control
* USABILITY: When adding a new track, open instrument selector
* USABILITY: Only show tool cursor when action is valid
   * note/rest: when over a valid insert point
   * accidental: when over a note and accidental is valid for that note
* BUG: switching tool using shortcuts doesn’t update tool dock anymore
* BUG: changing time signature does not update all tracks
* BUG: removing a track does not remove the playback source
* BUG: Collapsed state for docks is not persisted
* BUG: Crash in thread causes problems
   * crash dialog must be created from mainthread
   * send event to main thread
* UI: Tool dock should have a fixed height
* CLEANUP: rename all tests to test_*.py
* CLEANUP: tests for UI classes
* CLEANUP: replace runtests by setup.py test
* object browser
* dev dock
   * process memory usage
* lot’s of STDERR on exit
   ** (process:26761): CRITICAL **: fluid_synth_sfont_unref: assertion 'sfont_info != NULL' failed
   fluidsynth: warning: No preset found on channel 245 [bank=0 prog=0]
   is that a problem?
   * probably related to the sfont shuffling between master_synth and playback synths.
* FEATURE: doodle mode
      * record raw midi
      * place markers "this was good"
      * midi controller, button, etc.
      * quantize
* FEATURE: complex instruments
      * need more complex structure that "one instrument per track"
      * instrument definition is track type specific
      * percussion track:
      * list of instruments
      * score track:
      * base instrument
      * (optionally) separate instrument for staccato, pizzicato, ... notes
      * play mode "percussion" (only note on), "note" (note on/off based on duration), ...
* FEATURE: play back tuning
      * all event based tracks
      * global settings
      * per-track settings
      * add to/override global settings
      * shift note on/off times
      * randomize
      * velocity, timeshift based on beat position ("swing -> delay note on on off beat").




* documentation
* doc with html browser
* chord naming
* enable for track
* link chords to documentation, description of chord, etc.
* i18n, german translation
* polyphonic synth for plain wav files
* filters
* parameter timeline
* grand piano staff
* support multiple note sequences per track
* percussion track
* assign different instruments to note symbols
* support multiple instruments per track
* realtime midi input
* recorded audio track
* realtime input
* export to single file archive
* standalone player and exporter
* import/export other formats
* musicxml
* http://www.lilypond.org/doc/v2.18/input/regression/musicxml/collated-files.html (might be useful, if the site is up..)
* abc http://abcnotation.com/
* midi
* vertical rendering
* fit measures into horizontal space, then continue going down
* support more than just stereo
* treat each track as a point in space (possibly with movement and direction)
* output channels are “microphones” placed in space
* render output using a 3d simulation
* saw some library doing that somewhere…
* text input
* show a text input widget below current measure with a text representation of the contents, let user edit and update measure display as it is changed.
* key shortcuts to jump to next/prev measure, up/down a track.
* define syntax, something like ABC
* http://opensoundcontrol.org/introduction-osc


* MIDI controller
      * apc key 25 button mapping: https://github.com/osakared/apc-key-25-bitwig/blob/master/APCKey25.control.js

* Misc notes
      * std icons: http://standards.freedesktop.org/icon-naming-spec/icon-naming-spec-latest.html
      * symbols: http://en.wikipedia.org/wiki/List_of_musical_symbols

* standalone player
* --driver
* -o wav
* statusbar
* show current note value
* select tool
* highlight selected measure
* TAB -> cycle through tools
* ? -> show keyboard shortcuts
* ctrl -> insert pause
* space -> pan view
* helper lines for low/high notes
* volume markers
* edit measures
* context menu over active measure
* remove
* insert left
* insert right
* cut
* copy
* paste
* link
* change clef
* change key
* tracks
* add
* remove
* move up/down
* set instrument
* set volume
* set octave
* time jitter
* load/save project
* remember opened projects
* recent projects menu
* bookmarks
* project properties
* composer, copyright, etc.
* “text” tracks
* free text annotations
* beam score to tablet, sync display with playback
