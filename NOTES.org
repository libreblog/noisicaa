# -*- org-tags-column: -98 -*-

* TODO Control tracks									      :FR:
Any controllable value can be turned into a control track.
Icon next to controllable values, drag'n'drop onto editor.

- should control tracks be measured?
  - if not, inserting a new measure across all tracks becomes non-obvious
  - if not, layouting needs to be reimplemented
    - each track has its own layout
    - but measures should still align
  - control tracks should still be rendered as a sequence of measures,
    aligned to the other tracks
  - if yes, moving control points across measure boundaries becomes
    non-trivial
- what happens when the song becomes shorter than a control track?
  - discard all control points past the end
    - clip last segment correctly?
  - or keep control points, but just don't show them
  - or keep track length
- splines?
- free hand
- properties
  - min/max
  - linear/log
  - unit (Hz, dB, %, ..)
- display current value under cursor position
- edit track properties
- implicit first and last segment
  - extend current value from start or end
- ControlEntitySource: compute value at a-rate

* TODO ToolDock: track specific tool set						      :FR:
- active track:
  only the active track gets edit events. clicking on another track makes
  that track active and changes the set of tools and the active tool.
- remember active tool per track type
- could also activate track by enter events
  - but if mouse then moves to tracks dock, it might cross other tracks causing confusion

* TODO Fixed horizontal time mapping							      :FR:
- Same horizontal interval maps to same musical time interval anywhere.
  Otherwise rendering control segments across measure boundaries becomes very confusing.
- ScoreMeasure has to fit into given space no matter what.
- Zooming along time axis.

* turn any node parameter into a control input port					      :FR:
- ports can be added and removed on the fly
- parameter description has sufficient data to describe port
- parameter is always a-rate in csound

* Exception when closing a project 							     :BUG:
- 'dict_values' object is not an iterator
- no traceback?

* Abstract base class for ui mixins							 :CLEANUP:
- to make pylint happy

* Revamp object model									 :CLEANUP:
- root manages heap of objects
- when creating object, add it to heap
  - __init__ needs to know root, so it can create children
  - or separate setup() method?
- all object references (child, lists, etc.) only store IDs in state, do
  lazy dereferencing on __get__

* Fully replace obsolete node descriptions						 :CLEANUP:
* Track type: percussion								      :FR:
** move beats to arbitrary positions
* Sometimes hangs during shutdown							     :BUG:
Last sign of life:
  INFO    :18195:7f91c16bc700:ui.editor_app: Shutting down.

* Custom csound filter node								      :FR:
- make port list editable
- report csound errors back to UI
- two engines - new/old code - in parallel, slide from old to new
  - init new code
  - start processing new code , output at 0
  - slide old=100%, new=0% -> old=0%, new=100%
  - stop processing old code
  - clean up old code
  - how does that work with arbitrary output nodes? and events?
- edit widget with syntax highlighting
- add to library
  - editing inproject only changes local state
  - explicit sync to library?
  - any filter can be saved in library as a "preset"
* merge consecutive commands								      :FR:
- keep a single item in-memory buffer before writing commands to disk
- when adding commands to log
  - call prev_cmd.try_merge_with(latest_cmd)
    - command class must be marked as mergable
    - if same class, append mutation log of latest_cmd to prev_cmd?
    - or just handle simple attribute changes, overwriting the target value
  - if returns False, push latest_cmd to log (flushing prev_cmd to disk)

* per measure time signature								      :FR:
Tracks can have different time signatures, measures do not have to align
vertically.
* replace SheetPropertyTrack by a controllable parameter				      :FR:
* SIGSEGV when editing PipelineGraphView						   :CRASH:
Possibly caused by the use of QGraphicsEffect for dropshadows?

* PipelineGraphView: node properties dock sometimes does not open.			     :BUG:
Dock shortly pops up, then disappears. Clicking on any other widget in
the docking area then SIGSEGVs. Does QT not like opening docks directly
as floating? There might have been a X11 error message in the log.

* GIL free audio pipeline								      :FR:
* Plugin support									      :FR:
** LADSPA
** LV2
* Render audio to file									      :FR:
* NodeDB: start_scan									      :FR:
How to report scan progress back?
First a quick scan to find candidate files?
* NodeDB: set search paths								      :FR:
Manage from settings dialog.
Search path per scanner (csound, ladspa, lv2, ...).
* NodeDB: cache DB									      :FR:
Storage location: $HOME/.cache/noisicaÃ¤
Track time of scan
Load cache on startup
Rescan if time of last scan > X

* PipelineGraphView: listeners to update UI when node parameters change.		      :FR:
* PipelineGraphView: edit node name							      :FR:
* Track volume/mute properties: change connect trackmixer node instead.			     :BUG:
* Color code tracks and measures.							      :FR:
Tracks: To group e.g. all percussion visually.
Measures: To group thematically related sections.
Popup menu provides palette of color, separate list of already used colors
(to make it easier to answer the question, which shade of green I used
before).

* Linked measures									      :FR:
Dereference: clone the pointed to measure and replace link with that copy.
If a group of linked measures is selected, only make one copy and link the
rest. E.g. A B A' B' [A' B' A' B'] -> A B A' B' C D C' D', where C=copy(A),
D=copy(B).
Explicit dereference all to create standalone clone for every selected
measure.

* PipelineGraphView: drop onto existing node to replace it.				      :FR:
Retain properties of the same name from replaced node.
Deny drop, if node is not compatible with existing node.
* PipelineGraphView: drop new node on connection.					      :FR:
Insert node between the connected nodes.
Deny drop, if node is not compatible with connection type.
Reorganize graph to make space for the new node.

* PipelineGraphView: node info in nodes list.						      :FR:
List of ports and their types.
Node description, etc.
* PipelineGraphView: disallow connections that create a cyclic graphs.			     :BUG:
Compute list of valid dest nodes and highlight those.
* PipelineGraphView: scrollwheel zoom.							      :FR:
* PipelineGraphView: drag to move.							      :FR:
* PipelineGraphView: no random jumping around when inserting new nodes.			      :FR:
* PipelineGraphView: multiple selections.						      :FR:
** ctrl-click to add/remove nodes from selection set.
** Way to select all upstream nodes of a node.
** Move nodes together.
** Remove all
* PipelineGraphView: visualize mute, volume, bypass state in UI				      :FR:
* PipelineGraphView: select port or connection filters node list to compatible nodes	      :FR:
* More instrument types									      :FR:
- simple samples
- SFZ

* Audio tracks										      :FR:
- keep separate list of audio clips
- drag'n'drop sections onto audio tracks
- a section is a clip or range of a clip
- per section envelope
  - short (few msec) ramp up/down to avoid clicks
* cut, copy, paste									      :FR:
- Use QClipboard
- select multiple items
  - ranges or sparse sets
- measures across different tracks
- different selection types
  - mutually exclusive
    - when a different type is selected, clear selection
  - measures
  - tracks
  - notes

* copy/link via drag'n'drop								      :FR:
* TracksDock: moving tracks doesn't work						     :BUG:
* player needs to get lock on state							     :BUG:
possible exception when changing project while playing
* Tool not visible on initial load							     :BUG:
* changing backend in settings crashes pipeline loop					     :BUG:
* generic csound filter									      :FR:
- define audio and control ports
- also event inputs for instruments?
- freeform text input for csound code

* Undo/redo doesn't replay pipeline mutations						     :BUG:
- trigger pipeline mutations from listeners on model
- don't trigger mutations while replaying log during load
* use recordfile for command log							 :CLEANUP:
   * need file offset
   * read record from offset
* cleanup and write docstring for storage.py						 :CLEANUP:
* delete unused objects on client side, when						 :CLEANUP:
   * obj prop set to None
   * item deleted from objlist
   * objlist cleared
* non-existing file on cmdline creates project						      :FR:
   * remove + hack

* main process keeps track of project processes						      :FR:
   * opening existing project reconnects to that process

* per process cpu monitor								      :FR:
   * collect cpu time with 1ms precision
   * separate thread
   * send bulk data every O(100) ms to UI
   * plot along pipeline perf chart
* PipelinePerfMonitor: aggregate data over time						      :FR:
- avg duration and std deviation per span.
- how to visualize averaged gantt chart?
* PipelinePerfMonitor: per span graphs
- duration
- start time relative to parent span
- start time relative to frame start

* process stats										      :FR:
   * STATS call to manager
   * name, pid, cpu, memory
   * graphs

* stats for backend buffer length							      :FR:

* project_fuzztest.py									 :TESTING:
   * launch ProjectProcess using same eventloop
   * use inmemory filesystem
   * random actions
      * close and reopen
      * create checkpoint
      * undo/redo
      * player interaction
      * execute all existing commands
      * coverage report
* integrate pylint into test suite							 :TESTING:
   * add test case with test for each covered module
   * run pylint and fail test if any found messages
* XML schema for node descriptions							 :TESTING:
   * validate all nodes from library against schema
* parse all csound scripts for syntax errors						 :TESTING:
UI Improvements

* better handling of remote exceptions							 :CLEANUP:
   * traceback
   * every exception crashes
      * Server errors terminate server process
      * traceback sent to process manager, propagate to process owner
      * exceptions in threads terminate process
      * handle simultaneous exceptions in multiple threads

* master volume										      :FR:
if backend supports volume, use that. e.g. set alsa mixer volume.
otherwise set volume on outgoing samples.

* NodeType -> NodeDescripion								 :CLEANUP:
* Description classes for ports and node properties					 :CLEANUP:
* move generic Qt classes to noisicaa.qt						 :CLEANUP:
* LoadHistoryWidget									 :CLEANUP:
* fix left over TODOs									 :CLEANUP:
* remove or fix commented code								 :CLEANUP:
* ServerError and ClientError exception base classes.					 :CLEANUP:
- ClientError is returned to client
- ServerError causes server to crash
* factor out common Client, Process, Session code					 :CLEANUP:
* separate client, server and common code in music					 :CLEANUP:
* proper classes for mutations emitted from state.py					 :CLEANUP:
* move tests from state_test.py to model_base_test.py					 :CLEANUP:
* find a proper test sample for audio settings dialog					 :CLEANUP:
* move initial project mutations to BaseProject						 :CLEANUP:
* node_db imports all nodes and populates itself					 :CLEANUP:
* use registry instance instead of class attributes to track classes			 :CLEANUP:
that allows distinct class hierarchies and is cleaner for testing
music.commands.Command.command_classes
* AudioProcClient should use callbacks for mutation and status distribution		 :CLEANUP:
instead over overriding handle_pipeline_*, client code should register a callback
* base class for audioproc nodes created from a NodeDescription				 :CLEANUP:

* add a concept of "action receivers"							 :CLEANUP:
- EditorWindow has a single object currently being the "action receivers"
  - use Qt focus?
- global actions, e.g. cut, copy, paste, are sent to that object
- if receivers doesn't handle it, pass it on to parent
  - use custom Qt events?

* == unsorted nodes from gdoc =================================================

* use URIs to open files
   * always abs path
   * demo://params

* use stats calls to other processes
   * for pipeline utilization
* TracksDock: drag'n'drop to organize tracks
Assorted TODOs
* pass done callback to start_process
* first flesh out AudioProc process
   * prevent cycles 
   * handle node parameters
      * default values for parameters
      * update parameters
         * open dialog
         * mark parameters as mutable
         * client and process methods
   * pass user-data along with commands, pass back to client along with mutations. use for e.g. initial position of nodes when dragging.
   * monitors
      * attach to any input or output port
      * for audioports
         * waveform, vumeter, spectrum
   * system midi event source 
      * one port per channel?
   * support note volume
      * just multiply each audiooutput buffer after run()?
   * race condition in audioproc_client_test.ProxyTest.test_remove_node?
      * occasional "ERROR:noisicaa.audioproc.audioproc_process:PUBLISH_STATUS failed with exception: 'NoneType' object has no attribute 'write'"
* UI state vs. project state
   * UI state:
      * current sheet, track, etc.
      * selections
      * position in view, zoom level, etc.
   * there could be multiple UIs for a project
   * same UI state spans projects
      * window/dock positions, sizes
   * project mutations might affect UI state
      * selected track is removed, etc.
      * undo should recreate related UI state changes
         * undo delete current track -> re-added track becomes current
* cli:
   * subcommands 
      * edit path
      * create path
      * play path 
      * encode path
   * global vs. per command flags
   * move command handlers to submodules
* CLEANUP: Use state pattern to handle tools
* UI: show on cursor when an operation is not allowed
* UI: press âhâ to highlight all locations where the current tool is applicable
* ties/slurs:
   * either: note groups or markers
   * markers:
      * begin, continue, end
      * adding begin/continue marker, adds end marker to next note
      * continue/end marker implies prev note has begin/continue marker
      * note can have multiple markers
         * A(b) B(c,b) C(e,c) D(e):
  
         * should markers have some group_id to identify which slur they belong to?
         * would it be sufficient to just list the group_ids for each slur that a note belongs to? if itâs the beginning/middle/end could be deduced. but that knowledge is handy for rendering and playback
   * groups:
   * track wide list of groups
   * add notes to groups
   * notes have reference to groups
   * find other notes in group requires cyclic references
   * edit flows:
   * click on note that is currently âendâ
   * becomes âcontinueâ, next note becomes âendâ
   * click on note before âbeginâ
   * becomes âbeginâ, next note becomes âcontinueâ
   * click on note that is currently âbeginâ, âcontinueâ
   * no-op
* midi
   * MidiHub
   * list keyboards, controls, buttons - not ports
   * route messages to driver
   * drivers
   * generic_midi_keyboard
   * driver configs
   * velocity function (min, max, gamma)
   * octave transpose
   * libalsa
   * more generic DeviceInfo, instead of Client-/PortInfo
* don't leave trash behind, if Project.create fails
* log_dump util
* https://travis-ci.org/ integration
* measure layout
   * align notes across tracks
* proper chord rendering
* ghost note at insert point
   * correct insert position for last note in measure
   * use tinted note instead of transparent
   * http://www.qtcentre.org/threads/53946-Is-it-possible-to-change-color-of-a-QGraphicsSvgItem
* selections
   * select measures & tracks
   * clear
   * transpose
   * cut, copy, paste
* InstrumentLibrary
   * update UIState as changes happen
   * use commands for changing library state
   * persist state
   * main instrument library - where should the state go?
   * track selection dialog: store ui_state under track
* signal buffer underruns
* when muting a track during playback, remove highlighted note
* more efficient layouting
   * measureitem.recomputelayout tells sheet about changes
   * sheet decides which measures need relayouting
   * just update measure positions
* UI: only show clef, time-, key signature when different from previous measure
* UI: cursor graphics item position should be updated when the view is scrolled.
* UI: better scrolling when following the playback position
   * either smooth scrolling, or jump one measure at a time.
* UI: time/key signature submenus should indicate current.
* USABILITY: Clicking on/editing a track on the sheet should make it the current track
* USABILITY: Better widget for volume control
* USABILITY: When adding a new track, open instrument selector
* USABILITY: Only show tool cursor when action is valid
   * note/rest: when over a valid insert point
   * accidental: when over a note and accidental is valid for that note
* BUG: switching tool using shortcuts doesnât update tool dock anymore
* BUG: changing time signature does not update all tracks
* BUG: removing a track does not remove the playback source
* BUG: Collapsed state for docks is not persisted
* BUG: Crash in thread causes problems
   * crash dialog must be created from mainthread
   * send event to main thread
* UI: Tool dock should have a fixed height
* CLEANUP: rename all tests to test_*.py
* CLEANUP: tests for UI classes
* CLEANUP: replace runtests by setup.py test
* FEATURE: rendering
   * file metadata
   * persist dialog values per-sheet
   * more formats: ogg, wav, mp3, ape
   * per-format options: bitrate, vbr/cbr, â¦
   * open file as *.part, rename at end, delete on failure
   * open dir in filemanager
   * open in external media player
* object browser
* dev dock
   * process memory usage
* lotâs of STDERR on exit
   ** (process:26761): CRITICAL **: fluid_synth_sfont_unref: assertion 'sfont_info != NULL' failed
   fluidsynth: warning: No preset found on channel 245 [bank=0 prog=0]
   is that a problem?
   * probably related to the sfont shuffling between master_synth and playback synths.
* FEATURE: doodle mode
      * record raw midi
      * place markers "this was good"
      * midi controller, button, etc.
      * quantize
* FEATURE: complex instruments
      * need more complex structure that "one instrument per track"
      * instrument definition is track type specific
      * percussion track:
      * list of instruments
      * score track:
      * base instrument
      * (optionally) separate instrument for staccato, pizzicato, ... notes
      * play mode "percussion" (only note on), "note" (note on/off based on duration), ...
* FEATURE: play back tuning
      * all event based tracks
      * global settings
      * per-track settings
      * add to/override global settings
      * shift note on/off times
      * randomize
      * velocity, timeshift based on beat position ("swing -> delay note on on off beat").




* documentation
* doc with html browser
* chord naming
* enable for track
* link chords to documentation, description of chord, etc.
* i18n, german translation
* polyphonic synth for plain wav files
* filters
* parameter timeline
* grand piano staff
* support multiple note sequences per track
* percussion track
* assign different instruments to note symbols
* support multiple instruments per track
* realtime midi input
* recorded audio track
* realtime input
* export to single file archive
* standalone player and exporter
* import/export other formats
* musicxml
* http://www.lilypond.org/doc/v2.18/input/regression/musicxml/collated-files.html (might be useful, if the site is up..)
* abc http://abcnotation.com/
* midi
* vertical rendering
* fit measures into horizontal space, then continue going down
* support more than just stereo
* treat each track as a point in space (possibly with movement and direction)
* output channels are âmicrophonesâ placed in space
* render output using a 3d simulation
* saw some library doing that somewhereâ¦
* text input
* show a text input widget below current measure with a text representation of the contents, let user edit and update measure display as it is changed.
* key shortcuts to jump to next/prev measure, up/down a track.
* define syntax, something like ABC
* http://opensoundcontrol.org/introduction-osc


* MIDI controller
      * apc key 25 button mapping: https://github.com/osakared/apc-key-25-bitwig/blob/master/APCKey25.control.js

* Misc notes
      * std icons: http://standards.freedesktop.org/icon-naming-spec/icon-naming-spec-latest.html
      * symbols: http://en.wikipedia.org/wiki/List_of_musical_symbols

* standalone player
* --driver
* -o wav
* statusbar
* show current note value
* select tool
* highlight selected measure
* TAB -> cycle through tools
* ? -> show keyboard shortcuts
* ctrl -> insert pause
* space -> pan view
* helper lines for low/high notes
* volume markers
* edit measures
* context menu over active measure
* remove
* insert left
* insert right
* cut
* copy
* paste
* link
* change clef
* change key
* tracks
* add
* remove
* move up/down
* set instrument
* set volume
* set octave
* time jitter
* load/save project
* remember opened projects
* recent projects menu
* track project is modified status
* display in tab title
* autosave
* bookmarks
* project properties
* composer, copyright, etc.
* âtextâ tracks
* free text annotations
* beam score to tablet, sync display with playback
