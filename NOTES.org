* TODO Move google doc to this file.
* TODO SIGSEGV when editing PipelineGraphView			      :CRASH:
Possibly caused by the use of QGraphicsEffect for dropshadows?

* TODO PipelineGraphView: node properties dock sometimes does not open. :BUG:
Dock shortly pops up, then disappears. Clicking on any other widget in
the docking area then SIGSEGVs. Does QT not like opening docks directly
as floating? There might have been a X11 error message in the log.

* TODO GIL free audio pipeline						 :FR:
* TODO Plugin support							 :FR:
** TODO LADSPA
** TODO LV2
* TODO Render audio to file						 :FR:
* NodeDB: start_scan							 :FR:
How to report scan progress back?
First a quick scan to find candidate files?
* NodeDB: set search paths						 :FR:
Manage from settings dialog.
Search path per scanner (csound, ladspa, lv2, ...).
* NodeDB: cache DB							 :FR:
Storage location: $HOME/.cache/noisicaä
Track time of scan
Load cache on startup
Rescan if time of last scan > X


* PipelineGraphView: listeners to update UI when node parameters change. :FR:
* PipelineGraphView: edit node name					 :FR:
* Track volume/mute properties: change connect trackmixer node instead. :BUG:
* PipelineGraphView: drop onto existing node to replace it.		 :FR:
Retain properties of the same name from replaced node.
Deny drop, if node is not compatible with existing node.
* PipelineGraphView: drop new node on connection.			 :FR:
Insert node between the connected nodes.
Deny drop, if node is not compatible with connection type.
* PipelineGraphView: node info in nodes list.				 :FR:
List of ports and their types.
Node description, etc.
* PipelineGraphView: disallow connections that create a cyclic graphs.  :BUG:
Compute list of valid dest nodes and highlight those.
* PipelineGraphView: scrollwheel zoom.					 :FR:
* PipelineGraphView: drag to move. 					 :FR:
* PipelineGraphView: no random jumping around when inserting new nodes.  :FR:
* PipelineGraphView: multiple selections. 				 :FR:
** Move nodes together.

* PipelineGraphView:							 :FR:
* PipelineGraphView:							 :FR:
* PipelineGraphView:							 :FR:
* == unsorted nodes from gdoc =================================================

* pipeline graph editor
   * later improvements
      * scrollwheel zoom
      * drag to move
      * don't scroll when inserting node
      * select multiple nodes
         * track set of selected items
         * move together
         * remove all
         * double click on node to select it and all upstream nodes?
         * rubber band
         * ctrl click to add to/remove from selection set
      * select port or connection filters node list to compatible nodes
      * visualize mute, volume, bypass state in UI


Greater Picture
What's essential to make it useful?
* filters
* control tracks
* cut, copy, paste
* more instrument types
* beat track
* reimplement rendering
Known bugs
* TracksDock: moving tracks doesn't work
* player needs to get lock on state, possible exception when changing project while playing
* Tool not visible on initial load
* changing backend in settings crashes pipeline loop
Filters
* filter chains vs. free form graph
   * filter chains
      * easier to use, UI is just a simple list of filters per track
      * covers most use-cases
   * free form graph
      * everything is possible
      * harder to use for simple cases
   * best of both?
      * UI a list with filter chain per track
      * advanced UI allows arbitrary filter graphs
      * how to sync changes of graph back to filter chains?
         * group nodes coming from filter chains
         * inputs/outputs are statically connected, just order can be changed
* generic csound filter
   * define audio and control ports
   * also event inputs for instruments?
   * freeform text input for csound code
Persistence
* cleanup and write docstring for storage.py
* adapt recordfile
   * need file offset
   * read record from offset
* file structure
   * space of possible states is highly branching tree
   * root is empty project
   * nodes cannot be enumerated, only meaningful property is distance from root = minimal steps required to get there
   * user can chose to move down or up (=undo) again, defining a path through the state space
   * downward moves are defined by the user's choice
   * upward moves are unambiguous
   * every user decision is precious and must not be forgotten
   * when reconstructing state from log, parts of the path can be skipped
   * single log file with all history
      * split file after nMB
* micro language for mutations
   * MutationOpCode(cmd, args)
      * all args must be serializable
   * tests
      * set property object or None
      * move value between parents (property or list)
   * move list item should not store object
      * just obj_id for validation
   * other side effect from commands
      * e.g. pipeline mutations
      * a) trigger from model mutations
      * b) track as operations
      * moving track should not cleanup and setup node again, but just reattach it
* use URIs to open files
   * always abs path
   * demo://params
* main process keeps track of project processes
   * opening existing project reconnects to that process
* delete unused objects on client side, when
   * obj prop set to None
   * item deleted from objlist
   * objlist cleared
* non-existing file on cmdline creates project
   * remove + hack
Optimize Audio Pipeline
* explicit GC after every frame
* per process cpu monitor
   * collect cpu time with 1ms precision
   * separate thread
   * send bulk data every O(100) ms to UI
   * plot along pipeline perf chart
* stats for backend buffer length
* pipeline profiler
   * UI's audioproc reports perf data to UI
   * spans need consistent, unique names
   * track thread_id
   * visualize
      * collect history of profiles per frame
      * render realtime or scroll back in time
      * show avg. duration, std deviation per row
      * how to aggregate data over time?
      * per span graphs
         * duration
         * start time relative to parent
         * start time relative to prev sibling
* process stats
   * STATS call to manager
   * name, pid, cpu, memory
   * graphs
* use stats calls to other processes
   * for pipeline utilization
* Improve testing
* project_fuzztest.py
   * launch ProjectProcess using same eventloop
   * use inmemory filesystem
   * random actions
      * close and reopen
      * create checkpoint
      * undo/redo
      * player interaction
      * execute all existing commands
      * coverage report
* pylint doesn't work with vext?
* integrate pylint into test suite
   * add test case with test for each covered module
   * run pylint and fail test if any found messages
* XML schema for node descriptions
   * validate all nodes from library against schema
* parse all csound scripts for syntax errors
UI Improvements
* TracksDock: drag'n'drop to organize tracks
Assorted TODOs
* structure this doc
   * cleanups
   * next steps
   * later ideas
   * known bugs
* reanimate playback
   * timepos management 
      * report timepos back to client (ui not upstream audioproc)
      * player timepos should be reportrd to the UI when the frame is fed into backend
   * stopping playback should stop all playing notes
      * via sending a reset to all nodes?
         * send PipelineReset command along with FrameData
      * or should the player keep track of active notes and send NoteOff events?
* pass done callback to start_process
* first flesh out AudioProc process
   * prevent cycles 
   * handle node parameters
      * default values for parameters
      * update parameters
         * open dialog
         * mark parameters as mutable
         * client and process methods
   * pass user-data along with commands, pass back to client along with mutations. use for e.g. initial position of nodes when dragging.
   * monitors
      * attach to any input or output port
      * for audioports
         * waveform, vumeter, spectrum
   * system midi event source 
      * one port per channel?
   * support note volume
      * just multiply each audiooutput buffer after run()?
   * race condition in audioproc_client_test.ProxyTest.test_remove_node?
      * occasional "ERROR:noisicaa.audioproc.audioproc_process:PUBLISH_STATUS failed with exception: 'NoneType' object has no attribute 'write'"
* better handling of remote exceptions
   * traceback
   * every exception crashes
      * Server errors terminate server process
      * traceback sent to process manager, propagate to process owner
      * exceptions in threads terminate process
      * handle simultaneous exceptions in multiple threads
* ProcessManager: run all in single process mode
* switch audio backend is broken
* UI state vs. project state
   * UI state:
      * current sheet, track, etc.
      * selections
      * position in view, zoom level, etc.
   * there could be multiple UIs for a project
   * same UI state spans projects
      * window/dock positions, sizes
   * project mutations might affect UI state
      * selected track is removed, etc.
      * undo should recreate related UI state changes
         * undo delete current track -> re-added track becomes current
* cli:
   * subcommands 
      * edit path
      * create path
      * play path 
      * encode path
   * global vs. per command flags
   * move command handlers to submodules
* master volume
   * if backend supports volume, use that. e.g. set alsa mixer volume. otherwise set volume on outgoing samples
* CLEANUP: Use state pattern to handle tools
* UI: show on cursor when an operation is not allowed
* UI: press ‘h’ to highlight all locations where the current tool is applicable
* ties/slurs:
   * either: note groups or markers
   * markers:
      * begin, continue, end
      * adding begin/continue marker, adds end marker to next note
      * continue/end marker implies prev note has begin/continue marker
      * note can have multiple markers
         * A(b) B(c,b) C(e,c) D(e):
  
         * should markers have some group_id to identify which slur they belong to?
         * would it be sufficient to just list the group_ids for each slur that a note belongs to? if it’s the beginning/middle/end could be deduced. but that knowledge is handy for rendering and playback
   * groups:
   * track wide list of groups
   * add notes to groups
   * notes have reference to groups
   * find other notes in group requires cyclic references
   * edit flows:
   * click on note that is currently ‘end’
   * becomes ‘continue’, next note becomes ‘end’
   * click on note before ‘begin’
   * becomes ‘begin’, next note becomes ‘continue’
   * click on note that is currently ‘begin’, ‘continue’
   * no-op
* midi
   * MidiHub
   * list keyboards, controls, buttons - not ports
   * route messages to driver
   * drivers
   * generic_midi_keyboard
   * driver configs
   * velocity function (min, max, gamma)
   * octave transpose
   * libalsa
   * more generic DeviceInfo, instead of Client-/PortInfo
* don't leave trash behind, if Project.create fails
* log_dump util
* https://travis-ci.org/ integration
* measure layout
   * align notes across tracks
* proper chord rendering
* ghost note at insert point
   * correct insert position for last note in measure
   * use tinted note instead of transparent
   * http://www.qtcentre.org/threads/53946-Is-it-possible-to-change-color-of-a-QGraphicsSvgItem
* selections
   * select measures & tracks
   * clear
   * transpose
   * cut, copy, paste
* InstrumentLibrary
   * update UIState as changes happen
   * use commands for changing library state
   * persist state
   * main instrument library - where should the state go?
   * track selection dialog: store ui_state under track
* signal buffer underruns
* when muting a track during playback, remove highlighted note
* more efficient layouting
   * measureitem.recomputelayout tells sheet about changes
   * sheet decides which measures need relayouting
   * just update measure positions
* UI: only show clef, time-, key signature when different from previous measure
* UI: cursor graphics item position should be updated when the view is scrolled.
* UI: better scrolling when following the playback position
   * either smooth scrolling, or jump one measure at a time.
* UI: time/key signature submenus should indicate current.
* USABILITY: Clicking on/editing a track on the sheet should make it the current track
* USABILITY: Better widget for volume control
* USABILITY: When adding a new track, open instrument selector
* USABILITY: Only show tool cursor when action is valid
   * note/rest: when over a valid insert point
   * accidental: when over a note and accidental is valid for that note
* BUG: switching tool using shortcuts doesn’t update tool dock anymore
* BUG: changing time signature does not update all tracks
* BUG: removing a track does not remove the playback source
* BUG: Collapsed state for docks is not persisted
* BUG: Crash in thread causes problems
   * crash dialog must be created from mainthread
   * send event to main thread
* UI: Tool dock should have a fixed height
* CLEANUP: rename all tests to test_*.py
* CLEANUP: tests for UI classes
* CLEANUP: replace runtests by setup.py test
* FEATURE: rendering
   * file metadata
   * persist dialog values per-sheet
   * more formats: ogg, wav, mp3, ape
   * per-format options: bitrate, vbr/cbr, …
   * open file as *.part, rename at end, delete on failure
   * open dir in filemanager
   * open in external media player
* object browser
* dev dock
   * process memory usage
* lot’s of STDERR on exit
   ** (process:26761): CRITICAL **: fluid_synth_sfont_unref: assertion 'sfont_info != NULL' failed
   fluidsynth: warning: No preset found on channel 245 [bank=0 prog=0]
   is that a problem?
   * probably related to the sfont shuffling between master_synth and playback synths.
* FEATURE: doodle mode
      * record raw midi
      * place markers "this was good"
      * midi controller, button, etc.
      * quantize
* FEATURE: complex instruments
      * need more complex structure that "one instrument per track"
      * instrument definition is track type specific
      * percussion track:
      * list of instruments
      * score track:
      * base instrument
      * (optionally) separate instrument for staccato, pizzicato, ... notes
      * play mode "percussion" (only note on), "note" (note on/off based on duration), ...
* FEATURE: play back tuning
      * all event based tracks
      * global settings
      * per-track settings
      * add to/override global settings
      * shift note on/off times
      * randomize
      * velocity, timeshift based on beat position ("swing -> delay note on on off beat").




* Cleanups
      * NodeType -> NodeDescripion
      * Description classes for ports and node properties 
      * move generic Qt classes to noisicaa.qt
      * LoadHistoryWidget
      * improve test coverage
      * fix left over TODOs
      * remove or fix commented code
      * ServerError and ClientError exception base classes.
      * ClientError is returned to client
      * ServerError causes server to crash
      * factor out common Client, Process, Session code
      * separate client, server and common code in music
      * proper classes for mutations emitted from state.py
      * move tests from state_test.py to model_base_test.py
      * make client side objects readonly
      * process_client calls special methods to modify
      * Property.set_internal
      * ObjectList.{insert,delete,clear}_internal
      * find a proper test sample for audio settings dialog
      * move initial project mutations to BaseProject
      * node_db imports all nodes and populates itself
      * use registry instance instead of class attributes to track classes
      * that allows distinct class hierarchies and is cleaner for testing
      * music.commands.Command.command_classes
      * AudioProcClient should use callbacks for mutation and status distribution
      * instead over overriding handle_pipeline_*, client code should register a callback
      * base class for audioproc nodes created from a NodeDescription


* Further features
      * documentation
      * doc with html browser
      * chord naming
      * enable for track
      * link chords to documentation, description of chord, etc.
      * i18n, german translation
      * polyphonic synth for plain wav files
      * filters
      * parameter timeline
      * grand piano staff
      * support multiple note sequences per track
      * percussion track
      * assign different instruments to note symbols
      * support multiple instruments per track
      * realtime midi input
      * recorded audio track
      * realtime input
      * cut, copy, paste, trim operations
      * operations are non-destructive to enable undo
      * volume changes, etc. implemented via filters
      * export to audio
      * export to single file archive
      * standalone player and exporter
      * import/export other formats
      * musicxml
      * http://www.lilypond.org/doc/v2.18/input/regression/musicxml/collated-files.html (might be useful, if the site is up..)
      * abc http://abcnotation.com/
      * midi
      * cut/copy/paste
      * vertical rendering
      * fit measures into horizontal space, then continue going down
      * support more than just stereo
      * treat each track as a point in space (possibly with movement and direction)
      * output channels are “microphones” placed in space
      * render output using a 3d simulation
      * saw some library doing that somewhere…
      * text input
      * show a text input widget below current measure with a text representation of the contents, let user edit and update measure display as it is changed.
      * key shortcuts to jump to next/prev measure, up/down a track.
      * define syntax, something like ABC
      * http://opensoundcontrol.org/introduction-osc


* MIDI controller
      * apc key 25 button mapping: https://github.com/osakared/apc-key-25-bitwig/blob/master/APCKey25.control.js

* Misc notes
      * std icons: http://standards.freedesktop.org/icon-naming-spec/icon-naming-spec-latest.html
      * symbols: http://en.wikipedia.org/wiki/List_of_musical_symbols




* Old TODOs
      * standalone player
      * --driver
      * -o wav
      * statusbar
      * show current note value
      * select tool
      * highlight selected measure
      * TAB -> cycle through tools
      * ? -> show keyboard shortcuts
      * ctrl -> insert pause
      * space -> pan view
      * helper lines for low/high notes
      * volume markers
      * edit measures
      * context menu over active measure
      * remove
      * insert left
      * insert right
      * cut
      * copy
      * paste
      * link
      * change clef
      * change key
      * tracks
      * add
      * remove
      * move up/down
      * set instrument
      * set volume
      * set octave
      * time jitter
      * load/save project
      * remember opened projects
      * recent projects menu
      * track project is modified status
      * display in tab title
      * autosave
      * bookmarks
      * project properties
      * composer, copyright, etc.




* Far out ideas
      * record midi
      * metronom
      * effects
      * add effect sequence per track
      * effect parameters change over time
      * “text” tracks
      * free text annotations
      * printing (via export and other tool?)
      * import
      * midi files
      * musicxml
      *       * export
      * midi
      * musicxml http://en.wikipedia.org/wiki/MusicXML
      * render to audio (mp3,ogg,flac,...)
      * beam score to tablet, sync display with playback


* About
      * Nostalgia: revive the ease of Deluxe Music Construction Set
      * Simple interface, focussed on making music, not making perfect score sheets
