#!/usr/bin/env python3

import argparse
import fnmatch
import logging
import os
import os.path
import sys
import unittest

import coverage

import pyximport
pyximport.install()

LIBDIR = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
sys.path.insert(0, LIBDIR)

def main(argv):
    parser = argparse.ArgumentParser()
    parser.add_argument('selectors', type=str, nargs='*')
    parser.add_argument('--debug', action='store_true', default=False)
    args = parser.parse_args(argv[1:])

    log_level = logging.DEBUG if args.debug else logging.ERROR
    logging.basicConfig(level=log_level)

    loader = unittest.defaultTestLoader
    suite = unittest.TestSuite()

    cov = coverage.Coverage(
        source=['noisicaa'],
        omit='*_*test.py',
        config_file=False)
    cov.set_option("run:branch", True)
    cov.start()

    for dirpath, dirnames, filenames in os.walk(
        os.path.join(LIBDIR, 'noisicaa')):
        if '__pycache__' in dirnames:
            dirnames.remove('__pycache__')

        for filename in filenames:
            if not fnmatch.fnmatch(filename, '*.py'):
                continue

            modpath = os.path.join(dirpath, filename)
            assert modpath.startswith(LIBDIR + '/')
            modpath = modpath[len(LIBDIR)+1:-3]
            modname = modpath.replace('/', '.')
            logging.info("Loading module %s...", modname)
            __import__(modname)

            if not fnmatch.fnmatch(filename, '*_*test.py'):
                continue

            if args.selectors:
                matched = False
                for selector in args.selectors:
                    if modname.startswith(selector):
                        matched = True
                if not matched:
                    continue

            modsuite = loader.loadTestsFromName(modname)
            suite.addTest(modsuite)

    runner = unittest.TextTestRunner(verbosity=2)
    result = runner.run(suite)

    cov.stop()
    cov_data = cov.get_data()
    total_coverage = cov.html_report(directory='/tmp/noisicaä.coverage')

    file_coverages = []
    for path in sorted(cov_data.measured_files()):
        _, statements, _, missing, _ = cov.analysis2(path)
        try:
            file_coverage = 1.0 - 1.0 * len(missing) / len(statements)
        except ZeroDivisionError:
            file_coverage = 1.0
        file_coverages.append(
            (os.path.relpath(path, os.path.abspath(os.path.dirname(__file__))),
             file_coverage))
    file_coverages = sorted(file_coverages, key=lambda f: f[1])
    file_coverages = filter(lambda f: f[1] < 0.8, file_coverages)
    file_coverages = list(file_coverages)

    print()
    print("Total coverage: %.1f%%" % total_coverage)
    for path, file_coverage in file_coverages[:5]:
        print("% 3.1f%% %s" % (100 * file_coverage, path))
    print("Coverage report: file:///tmp/noisicaä.coverage/index.html")
    print()

    return 0 if result.wasSuccessful() else 1


if __name__ == '__main__':
    sys.exit(main(sys.argv))
